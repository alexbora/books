<HTML>

<TITLE>ANSI C Specification</TITLE>

<H1 ALIGN=CENTER>ANSI C Specification</H1>

<TABLE WIDTH="100%">
<TR>
<TD ALIGN=CENTER>
<A HREF="mailto:William.Waite@Colorado.edu">
<ADDRESS>William.Waite@Colorado.edu</ADDRESS></A></TD>
</TR>
</TABLE>
<HR>

This document describes the parsing, name analysis and type analysis
problems for ANSI C.
<DL>
<DT><A HREF="#s1">1  Scope</A></DT>
<DT><A HREF="#s2">2  Normative references</A></DT>
<DT><A HREF="#s3">3  Definitions and Conventions</A></DT>
<DL>
<DT><A HREF="#s3.1">3.1  c.gla</A></DT>
<DT><A HREF="#s3.2">3.2  c.con</A></DT>
<DT><A HREF="#s3.3">3.3  c.map</A></DT>
<DT><A HREF="#s3.4">3.4  c.lido</A></DT>
<DT><A HREF="#s3.5">3.5  c.oil</A></DT>
<DT><A HREF="#s3.6">3.6  c.c</A></DT>
<DT><A HREF="#s3.7">3.7  c.h</A></DT>
<DT><A HREF="#s3.8">3.8  c.pdl</A></DT>
<DT><A HREF="#s3.9">3.9  c.specs</A></DT>
<DT><A HREF="#s3.10">3.10  c.head</A></DT>
<DT><A HREF="#s3.11">3.11  c.init</A></DT>
<DT><A HREF="#s3.12">3.12  c.ctl</A></DT>
</DL>
<DT><A HREF="#s4">4  Compliance</A></DT>
<DT><A HREF="#s5">5  Environment</A></DT>
<DL>
<DT><A HREF="#s5.1">5.1  Conceptual models</A></DT>
<DL>
<DT><A HREF="#s5.1.1">5.1.1  Translation environment</A></DT>
<DL>
<DT><A HREF="#s5.1.1.1">5.1.1.1  Program structure</A></DT>
<DT><A HREF="#s5.1.1.2">5.1.1.2  Translation phases</A></DT>
<DT><A HREF="#s5.1.1.3">5.1.1.3  Diagnostics</A></DT>
</DL>
<DT><A HREF="#s5.1.2">5.1.2  Execution environments</A></DT>
</DL>
<DT><A HREF="#s5.2">5.2  Environmental considerations</A></DT>
<DL>
<DT><A HREF="#s5.2.1">5.2.1  Character sets</A></DT>
<DL>
<DT><A HREF="#s5.2.1.1">5.2.1.1  Trigraph sequences</A></DT>
<DT><A HREF="#s5.2.1.2">5.2.1.2  Multibyte characters</A></DT>
</DL>
<DT><A HREF="#s5.2.2">5.2.2  Character display semantics</A></DT>
<DT><A HREF="#s5.2.3">5.2.3  Signals and interrupts</A></DT>
<DT><A HREF="#s5.2.4">5.2.4  Environmental limits</A></DT>
</DL>
</DL>
<DT><A HREF="#s6">6  Language</A></DT>
<DL>
<DT><A HREF="#s6.1">6.1  Lexical elements</A></DT>
<DL>
<DT><A HREF="#s6.1.1">6.1.1  Keywords</A></DT>
<DT><A HREF="#s6.1.2">6.1.2  Identifiers</A></DT>
<DL>
<DT><A HREF="#s6.1.2.1">6.1.2.1  Scopes of identifiers</A></DT>
<DT><A HREF="#s6.1.2.2">6.1.2.2  Linkages of identifiers</A></DT>
<DT><A HREF="#s6.1.2.3">6.1.2.3  Name spaces of identifiers</A></DT>
<DT><A HREF="#s6.1.2.4">6.1.2.4  Storage duration of objects</A></DT>
<DT><A HREF="#s6.1.2.5">6.1.2.5  Types</A></DT>
<DT><A HREF="#s6.1.2.6">6.1.2.6  Compatible type and composite type</A></DT>
</DL>
<DT><A HREF="#s6.1.3">6.1.3  Constants</A></DT>
<DL>
<DT><A HREF="#s6.1.3.1">6.1.3.1  Floating constants</A></DT>
<DT><A HREF="#s6.1.3.2">6.1.3.2  Integer constants</A></DT>
<DT><A HREF="#s6.1.3.3">6.1.3.3  Enumeration constants</A></DT>
<DT><A HREF="#s6.1.3.4">6.1.3.4  Character constants</A></DT>
</DL>
<DT><A HREF="#s6.1.4">6.1.4  String literals</A></DT>
<DT><A HREF="#s6.1.5">6.1.5  Operators</A></DT>
<DT><A HREF="#s6.1.6">6.1.6  Punctuators</A></DT>
<DT><A HREF="#s6.1.7">6.1.7  Header names</A></DT>
<DT><A HREF="#s6.1.8">6.1.8  Preprocessing numbers</A></DT>
<DT><A HREF="#s6.1.9">6.1.9  Comments</A></DT>
</DL>
<DT><A HREF="#s6.2">6.2  Conversions</A></DT>
<DL>
<DT><A HREF="#s6.2.1">6.2.1  Arithmetic operands</A></DT>
<DL>
<DT><A HREF="#s6.2.1.1">6.2.1.1  Characters and integers</A></DT>
<DT><A HREF="#s6.2.1.2">6.2.1.2  Signed and unsigned integers</A></DT>
<DT><A HREF="#s6.2.1.3">6.2.1.3  Floating and integral</A></DT>
<DT><A HREF="#s6.2.1.4">6.2.1.4  Floating types</A></DT>
<DT><A HREF="#s6.2.1.5">6.2.1.5  Usual arithmetic conversions</A></DT>
</DL>
<DT><A HREF="#s6.2.2">6.2.2  Other operands</A></DT>
<DL>
<DT><A HREF="#s6.2.2.1">6.2.2.1  Lvalues and function designators</A></DT>
<DT><A HREF="#s6.2.2.2">6.2.2.2  void</A></DT>
<DT><A HREF="#s6.2.2.3">6.2.2.3  Pointer</A></DT>
</DL>
</DL>
<DT><A HREF="#s6.3">6.3  Expressions</A></DT>
<DL>
<DT><A HREF="#s6.3.1">6.3.1  Primary expressions</A></DT>
<DT><A HREF="#s6.3.2">6.3.2  Postfix operators</A></DT>
<DL>
<DT><A HREF="#s6.3.2.1">6.3.2.1  Array subscripting</A></DT>
<DT><A HREF="#s6.3.2.2">6.3.2.2  Function calls</A></DT>
<DT><A HREF="#s6.3.2.3">6.3.2.3  Postfix increment and decrement operators</A></DT>
</DL>
<DT><A HREF="#s6.3.3">6.3.3  Unary operators</A></DT>
<DL>
<DT><A HREF="#s6.3.3.1">6.3.3.1  Prefix increment and decrement operators</A></DT>
<DT><A HREF="#s6.3.3.2">6.3.3.2  Address and indirection operators</A></DT>
<DT><A HREF="#s6.3.3.3">6.3.3.3  Unary arithmetic operators</A></DT>
</DL>
<DT><A HREF="#s6.3.4">6.3.4  Cast operators</A></DT>
<DT><A HREF="#s6.3.5">6.3.5  Multiplicative operators</A></DT>
<DT><A HREF="#s6.3.6">6.3.6  Additive operators</A></DT>
<DT><A HREF="#s6.3.7">6.3.7  Bitwise shift operators</A></DT>
<DT><A HREF="#s6.3.8">6.3.8  Relational operators</A></DT>
<DT><A HREF="#s6.3.9">6.3.9  Equality operators</A></DT>
<DT><A HREF="#s6.3.10">6.3.10  Bitwise AND operator</A></DT>
<DT><A HREF="#s6.3.11">6.3.11  Bitwise exclusive OR operator</A></DT>
<DT><A HREF="#s6.3.12">6.3.12  Bitwise inclusive OR operator</A></DT>
<DT><A HREF="#s6.3.13">6.3.13  Logical AND operator</A></DT>
<DT><A HREF="#s6.3.14">6.3.14  Logical OR operator</A></DT>
<DT><A HREF="#s6.3.15">6.3.15  Conditional operator</A></DT>
<DT><A HREF="#s6.3.16">6.3.16  Assignment operators</A></DT>
<DL>
<DT><A HREF="#s6.3.16.1">6.3.16.1  Simple assignment</A></DT>
<DT><A HREF="#s6.3.16.2">6.3.16.2  Compound assignment</A></DT>
</DL>
<DT><A HREF="#s6.3.17">6.3.17  Comma operator</A></DT>
</DL>
<DT><A HREF="#s6.4">6.4  Constant Expressions</A></DT>
<DT><A HREF="#s6.5">6.5  Declarations</A></DT>
<DL>
<DT><A HREF="#s6.5.1">6.5.1  Storage-class specifiers</A></DT>
<DT><A HREF="#s6.5.2">6.5.2  Type specifiers</A></DT>
<DL>
<DT><A HREF="#s6.5.2.1">6.5.2.1  Structure and union specifiers</A></DT>
<DT><A HREF="#s6.5.2.2">6.5.2.2  Enumeration specifiers</A></DT>
<DT><A HREF="#s6.5.2.3">6.5.2.3  Tags</A></DT>
</DL>
<DT><A HREF="#s6.5.3">6.5.3  Type qualifiers</A></DT>
<DT><A HREF="#s6.5.4">6.5.4  Declarators</A></DT>
<DL>
<DT><A HREF="#s6.5.4.1">6.5.4.1  Pointer declarators</A></DT>
<DT><A HREF="#s6.5.4.2">6.5.4.2  Array declarators</A></DT>
<DT><A HREF="#s6.5.4.3">6.5.4.3  Function declarators (including prototypes)</A></DT>
</DL>
<DT><A HREF="#s6.5.5">6.5.5  Type names</A></DT>
<DT><A HREF="#s6.5.6">6.5.6  Type definitions</A></DT>
<DT><A HREF="#s6.5.7">6.5.7  Initialization</A></DT>
</DL>
<DT><A HREF="#s6.6">6.6  Statements</A></DT>
<DL>
<DT><A HREF="#s6.6.1">6.6.1  Labeled statements</A></DT>
<DT><A HREF="#s6.6.2">6.6.2  Compound statements</A></DT>
<DT><A HREF="#s6.6.3">6.6.3  Expression and null statements</A></DT>
<DT><A HREF="#s6.6.4">6.6.4  Selection statements</A></DT>
<DT><A HREF="#s6.6.5">6.6.5  Iteration statements</A></DT>
<DT><A HREF="#s6.6.6">6.6.6  Jump statements</A></DT>
</DL>
<DT><A HREF="#s6.7">6.7  External definitions</A></DT>
<DL>
<DT><A HREF="#s6.7.1">6.7.1  Function definitions</A></DT>
<DT><A HREF="#s6.7.2">6.7.2  External object definitions</A></DT>
</DL>
</DL>
<DT><A HREF="#s7">7  Library</A></DT>
<DT><A HREF="#s8">8  Consistent Renaming for Ordinary Identifiers</A></DT>
<DL>
<DT><A HREF="#s8.1">8.1  File scope</A></DT>
<DT><A HREF="#s8.2">8.2  Function prototype scope</A></DT>
<DL>
<DT><A HREF="#s8.2.1">8.2.1  Constraints on function declarators</A></DT>
<DT><A HREF="#s8.2.2">8.2.2  Implementation of function prototype scopes</A></DT>
</DL>
<DT><A HREF="#s8.3">8.3  Block scope</A></DT>
<DL>
<DT><A HREF="#s8.3.1">8.3.1  Determining the function environment</A></DT>
<DT><A HREF="#s8.3.2">8.3.2  Implementing the declaration state</A></DT>
</DL>
<DT><A HREF="#s8.4">8.4  Occurrences of ordinary identifiers</A></DT>
<DL>
<DT><A HREF="#s8.4.1">8.4.1  Ordinary identifiers and the definition table</A></DT>
<DT><A HREF="#s8.4.2">8.4.2  State information for an ordinary identifier definition</A></DT>
<DT><A HREF="#s8.4.3">8.4.3  Classifying occurrences of identifiers</A></DT>
<DT><A HREF="#s8.4.4">8.4.4  Establishing bindings for ordinary identifiers</A></DT>
</DL>
</DL>
<DT><A HREF="#s9">9  Internal Representation of Types</A></DT>
<DL>
<DT><A HREF="#s9.1">9.1  Creating type representations</A></DT>
<DL>
<DT><A HREF="#s9.1.1">9.1.1  Properties of types</A></DT>
<DT><A HREF="#s9.1.2">9.1.2  Array type</A></DT>
<DT><A HREF="#s9.1.3">9.1.3  Function type</A></DT>
<DT><A HREF="#s9.1.4">9.1.4  Pointer type</A></DT>
<DT><A HREF="#s9.1.5">9.1.5  Qualified type</A></DT>
</DL>
<DT><A HREF="#s9.2">9.2  Specification files</A></DT>
<DL>
<DT><A HREF="#s9.2.1">9.2.1  buildtype.h</A></DT>
<DT><A HREF="#s9.2.2">9.2.2  buildtype.c</A></DT>
<DT><A HREF="#s9.2.3">9.2.3  buildtype.HEAD.phi</A></DT>
<DT><A HREF="#s9.2.4">9.2.4  TypeRep.lido</A></DT>
<DT><A HREF="#s9.2.5">9.2.5  TypeRep.pdl</A></DT>
<DT><A HREF="#s9.2.6">9.2.6  TypeRep.specs</A></DT>
</DL>
</DL>
<DT><A HREF="#s10">10  Type Analysis</A></DT>
<DL>
<DT><A HREF="#s10.1">10.1  Declarations</A></DT>
<DL>
<DT><A HREF="#s10.1.1">10.1.1  Storage-class specifiers</A></DT>
<DT><A HREF="#s10.1.2">10.1.2  Type specifiers</A></DT>
<DT><A HREF="#s10.1.3">10.1.3  Type Qualifiers</A></DT>
</DL>
<DT><A HREF="#s10.2">10.2  Specification Files</A></DT>
<DL>
<DT><A HREF="#s10.2.1">10.2.1  type.lido</A></DT>
<DT><A HREF="#s10.2.2">10.2.2  type.pdl</A></DT>
<DT><A HREF="#s10.2.3">10.2.3  type.h</A></DT>
<DT><A HREF="#s10.2.4">10.2.4  type.specs</A></DT>
<DT><A HREF="#s10.2.5">10.2.5  type.head</A></DT>
<DT><A HREF="#s10.2.6">10.2.6  type.c</A></DT>
</DL>
</DL>
<DT><A HREF="#s11">11  Tree Type Computations</A></DT>
<DL>
<DT><A HREF="#s11.1">11.1  Type computations in expressions</A></DT>
<DL>
<DT><A HREF="#s11.1.1">11.1.1  Calculate possible and final types</A></DT>
<DT><A HREF="#s11.1.2">11.1.2  Calculate Operator Indications</A></DT>
</DL>
<DT><A HREF="#s11.2">11.2  Error Checking</A></DT>
<DL>
<DT><A HREF="#s11.2.1">11.2.1  Code to handle previously undefined variables</A></DT>
</DL>
<DT><A HREF="#s11.3">11.3  Specification files</A></DT>
</DL>
</DL>
<HR>

<A NAME="s1"><H1>1  Scope</H1></A>

This specification describes the form and establishes certain properties of a
program written in the C programming language.
It formalizes the representation of C programs, the syntax of the C
language, the correspondence between defining and applied occurrences of
identifiers in a program, the structure of C data types, and the type of
each expression in a program.
<P>
This specification can be processed by the Eli system to yield a ``lint''
program, a browsable HTML version of the document, or a PostScript version.
The specification can also be used as one component of a larger
specification from which a C compiler or special-purpose analyzer could be
generated, or it could form the basis for a specification of an extension to C.
<A NAME="s2"><H1>2  Normative references</H1></A>

The description here implements a portion of ANSI/ISO 9899-1990.
It is organized in parallel with that document, for easy verification of
the description.
<P>
This specification was developed and tested using Eli 4.0.
A complete description of Eli, including the current public-domain source
code, can be found at URL http://www.cs.colorado.edu/~eliuser/.
<A NAME="s3"><H1>3  Definitions and Conventions</H1></A>

<A NAME="s3.1"><H2>3.1  c.gla</H2></A>

A type-<TT>gla</TT> file contains the declarative specifications
of the character strings to be recognized in the input text.
<BLOCKQUOTE>
<A NAME="m1"><B>c.gla</B>[1]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m15"><I>Lexical elements</I>[15]</A>
  $#  (auxEOL)
  $\f
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s3.2"><H2>3.2  c.con</H2></A>

A type-<TT>con</TT> file contains the context-free grammar describing the way a
program is written.
<BLOCKQUOTE>
<A NAME="m2"><B>c.con</B>[2]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m43"><I>Constants</I>[43]</A>
<A HREF="#m51"><I>Enumeration constants</I>[51]</A>
<A HREF="#m54"><I>String sequence</I>[54]</A>
<A HREF="#m70"><I>Primary expressions</I>[70]</A>
<A HREF="#m71"><I>Postfix operators</I>[71]</A>
<A HREF="#m79"><I>Unary operators</I>[79]</A>
<A HREF="#m84"><I>Cast operators</I>[84]</A>
<A HREF="#m87"><I>Multiplicative operators</I>[87]</A>
<A HREF="#m89"><I>Additive operators</I>[89]</A>
<A HREF="#m92"><I>Bitwise shift operators</I>[92]</A>
<A HREF="#m94"><I>Relational operators</I>[94]</A>
<A HREF="#m97"><I>Equality operators</I>[97]</A>
<A HREF="#m100"><I>Bitwise AND operator</I>[100]</A>
<A HREF="#m102"><I>Bitwise exclusive OR operator</I>[102]</A>
<A HREF="#m104"><I>Bitwise inclusive OR operator</I>[104]</A>
<A HREF="#m106"><I>Logical AND operator</I>[106]</A>
<A HREF="#m109"><I>Logical OR operator</I>[109]</A>
<A HREF="#m112"><I>Conditional operator</I>[112]</A>
<A HREF="#m115"><I>Assignment operators</I>[115]</A>
<A HREF="#m125"><I>Comma operator</I>[125]</A>
<A HREF="#m126"><I>Constant Expressions</I>[126]</A>
<A HREF="#m127"><I>Declarations</I>[127]</A>
<A HREF="#m170"><I>Statements</I>[170]</A>
<A HREF="#m177"><I>External definitions</I>[177]</A>
<A HREF="#m178"><I>Function definitions</I>[178]</A>
<A HREF="#m14"><I>Optional symbols</I>[14]</A>

root:
  source .
source: / file .
file: translation_unit .
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s3.3"><H2>3.3  c.map</H2></A>

A type-<TT>map</TT> file describes the relationship between the phrase structure
of the input text and the tree structure on which computations are carried
out.
<BLOCKQUOTE>
<A NAME="m3"><B>c.map</B>[3]</A>==<BLOCKQUOTE><PRE>
MAPSYM
<A HREF="#m69"><I>Expressions</I>[69]</A>
<A HREF="#m116"><I>Map the assignment operator symbol</I>[116]</A>
<A HREF="#m133"><I>Declaration_specifier equivalence class</I>[133]</A>
<A HREF="#m154"><I>Direct_declarator equivalence class</I>[154]</A>
<A HREF="#m139"><I>Member_declarator equivalence class</I>[139]</A>
<A HREF="#m157"><I>Parameter_part equivalence class</I>[157]</A>
<A HREF="#m166"><I>Abstract_declarator equivalence class</I>[166]</A>
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s3.4"><H2>3.4  c.lido</H2></A>

A type-<TT>lido</TT> file describes computations to be carried out over the
abstract syntax tree of a program.
<BLOCKQUOTE>
<A NAME="m4"><B>c.lido</B>[4]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m18"><I>Function scope</I>[18]</A>
<A HREF="#m19"><I>File scope</I>[19]</A>
<A HREF="#m20"><I>Block scope</I>[20]</A>
<A HREF="#m24"><I>Tag scope</I>[24]</A>
<A HREF="#m23"><I>Function prototype scope</I>[23]</A>
<A HREF="#m28"><I>Disambiguation of member names</I>[28]</A>
<A HREF="#m129"><I>Semantics of declarations</I>[129]</A>
<A HREF="#m141"><I>Semantics of structure and union specifiers</I>[141]</A>
<A HREF="#m143"><I>Semantics of enumeration specifiers</I>[143]</A>
<A HREF="#m159"><I>Semantics of declarators</I>[159]</A>
<A HREF="#m182"><I>Access to the key attribute for ordinary identifiers</I>[182]</A>
<A HREF="#m144"><I>Tags</I>[144]</A>
<A HREF="#m148"><I>Use of an enumerated type tag</I>[148]</A>
<A HREF="#m145"><I>Check for multiply-declared tags</I>[145]</A>
<A HREF="#m147"><I>Tag that may or may not be a declaration</I>[147]</A>
<A HREF="#m149"><I>Forward definition of a tag</I>[149]</A>
<A HREF="#m150"><I>Anonymous structure, union or enumerated type</I>[150]</A>
<A HREF="#m161"><I>Pointer declarators</I>[161]</A>
<A HREF="#m163"><I>Array declarators</I>[163]</A>
<A HREF="#m164"><I>Function declarators (including prototypes)</I>[164]</A>
<A HREF="#m167"><I>Semantics of type names</I>[167]</A>
<A HREF="#m179"><I>Semantics of function definitions</I>[179]</A>
<A HREF="#m180"><I>Semantics of identifiers</I>[180]</A>
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s3.5"><H2>3.5  c.oil</H2></A>

A type-<TT>oil</TT> file describes the type model of a language.
<BLOCKQUOTE>
<A NAME="m5"><B>c.oil</B>[5]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m30"><I>Types</I>[30]</A>
<A HREF="#m56"><I>Implicit conversions</I>[56]</A>
<A HREF="#m72"><I>Array subscripting</I>[72]</A>
<A HREF="#m75"><I>Function calls</I>[75]</A>
<A HREF="#m77"><I>Postfix increment and decrement operators</I>[77]</A>
<A HREF="#m80"><I>Address and indirection operators</I>[80]</A>
<A HREF="#m82"><I>Unary arithmetic operators</I>[82]</A>
<A HREF="#m85"><I>Cast operator semantics</I>[85]</A>
<A HREF="#m88"><I>Multiplicative operator semantics</I>[88]</A>
<A HREF="#m90"><I>Additive operator semantics</I>[90]</A>
<A HREF="#m93"><I>Bitwise shift operator semantics</I>[93]</A>
<A HREF="#m95"><I>Relational operator semantics</I>[95]</A>
<A HREF="#m98"><I>Equality operator semantics</I>[98]</A>
<A HREF="#m101"><I>Bitwise AND operator semantics</I>[101]</A>
<A HREF="#m103"><I>Bitwise exclusive OR operator semantics</I>[103]</A>
<A HREF="#m105"><I>Bitwise inclusive OR operator semantics</I>[105]</A>
<A HREF="#m107"><I>Logical AND operator semantics</I>[107]</A>
<A HREF="#m110"><I>Logical OR operator semantics</I>[110]</A>
<A HREF="#m113"><I>Conditional operator semantics</I>[113]</A>
<A HREF="#m117"><I>Simple assignment</I>[117]</A>
<A HREF="#m123"><I>Compound assignment</I>[123]</A>
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s3.6"><H2>3.6  c.c</H2></A>

Operational specifications of some characteristics are provided directly in
a version of C that is compatible with C++.
This code is provided with controls so that it can be compiled with
non-ANSI C compilers.
<BLOCKQUOTE>
<A NAME="m6"><B>c.c</B>[6]</A>==<BLOCKQUOTE><PRE>
#include &quot;eliproto.h&quot;
#include &quot;err.h&quot;
#include &quot;envmod.h&quot;
#include &quot;termcode.h&quot;
#include &quot;pdl_gen.h&quot;
#include &quot;c.h&quot;

<A HREF="#m199"><I>State variable definitions</I>[199]</A>

<A HREF="#m220"><I>Initial classification of identifier terminals</I>[220]</A>
<A HREF="#m221"><I>Re-classify an identifier terminal to fit the context</I>[221]</A>
<A HREF="#m225"><I>Bind a defining occurrence of an ordinary identifier</I>[225]</A>

void
InitOrdinary()
{
<A HREF="#m209"><I>Initialize the array of definition table keys</I>[209]</A>
<A HREF="#m185"><I>Initialize the set of bindings having file scope</I>[185]</A>
}
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s3.7"><H2>3.7  c.h</H2></A>

Interface specifications for the operational descriptions are controlled so
that they may be included several times without the danger of multiple
definitions.
<BLOCKQUOTE>
<A NAME="m7"><B>c.h</B>[7]</A>==<BLOCKQUOTE><PRE>
#ifndef C_H
#define C_H
#include &quot;eliproto.h&quot;
#include &quot;envmod.h&quot;
#include &quot;RegionStack.h&quot;
#include &quot;OrdinaryIdStack.h&quot;
#include &quot;reparatur.h&quot;

<A HREF="#m204"><I>State variable declarations</I>[204]</A>

<A HREF="#m226"><I>Operation interfaces</I>[226]</A>

extern void InitOrdinary();

#endif
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


Initialization of the scanner must include initialization of the
environment for ordinary identifiers.
<BLOCKQUOTE>
<A NAME="m8"><B>scanops.h</B>[8]</A>==<BLOCKQUOTE><PRE>
#ifndef SCANOPS_H
#define SCANOPS_H

#define SCANPTR \
  { InitOrdinary(); TokenEnd = TEXTSTART; StartLine = TokenEnd - 1; }

#endif
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s3.8"><H2>3.8  c.pdl</H2></A>

<BLOCKQUOTE>
<A NAME="m9"><B>c.pdl</B>[9]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m211"><I>Properties of ordinary identifiers used during parsing</I>[211]</A>
<A HREF="#m63"><I>Function conversion operator</I>[63]</A>
<A HREF="#m146"><I>Property characterizing multiply-declared tags</I>[146]</A>
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s3.9"><H2>3.9  c.specs</H2></A>

<BLOCKQUOTE>
<A NAME="m10"><B>c.specs</B>[10]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m17"><I>Name analysis modules for label identifiers</I>[17]</A>
<A HREF="#m140"><I>Name analysis modules for member identifiers</I>[140]</A>
<A HREF="#m128"><I>Name analysis module for ordinary identifiers</I>[128]</A>
<A HREF="#m27"><I>Name spaces of identifiers</I>[27]</A>
<A HREF="#m184"><I>Create a module to stack Environment values</I>[184]</A>
<A HREF="#m206"><I>Create a module to stack DefTableKey values</I>[206]</A>
<A HREF="#m214"><I>Create a module to stack identifier state values</I>[214]</A>
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s3.10"><H2>3.10  c.head</H2></A>

<BLOCKQUOTE>
<A NAME="m11"><B>c.head</B>[11]</A>==<BLOCKQUOTE><PRE>
#include &quot;c.h&quot;
#include &quot;termcode.h&quot;
#include &quot;IdStateStack.h&quot;
<A HREF="#m22"><I>Computations for obtaining the tag environment from a declarator</I>[22]</A>
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s3.11"><H2>3.11  c.init</H2></A>

<BLOCKQUOTE>
<A NAME="m12"><B>c.init</B>[12]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m215"><I>Initialize the class of ordinary identifiers</I>[215]</A>
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s3.12"><H2>3.12  c.ctl</H2></A>

A type-<TT>ctl</TT> file contains directives controlling the behavior of Eli's
attribute grammar analyzer.
<BLOCKQUOTE>
<A NAME="m13"><B>c.ctl</B>[13]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m183"><I>Do not allow attribution during tree construction</I>[183]</A>
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s4"><H1>4  Compliance</H1></A>

This specification describes only the C language.
It makes no provision for either the library or the preprocessor.
<A NAME="s5"><H1>5  Environment</H1></A>

The environmental considerations described here apply to the processor
generated by Eli from this specification only.
If the specification is used as a component of a larger specification, then
some of these considerations may change.
<A NAME="s5.1"><H2>5.1  Conceptual models</H2></A>

<A NAME="s5.1.1"><H3>5.1.1  Translation environment</H3></A>

<A NAME="s5.1.1.1"><H4>5.1.1.1  Program structure</H4></A>

The processor described here deals with <EM>translation units</EM> -- source
files in which all preprocessor directives have been obeyed.
<A NAME="s5.1.1.2"><H4>5.1.1.2  Translation phases</H4></A>

The processor described here carries out only phases 5-7.
<A NAME="s5.1.1.3"><H4>5.1.1.3  Diagnostics</H4></A>

Error reports are issued for violations of the lexical and syntactic rules
of the language, for invalid definitions and uses of identifiers, and for
violations of the type rules.
<A NAME="s5.1.2"><H3>5.1.2  Execution environments</H3></A>

Not covered by this specification.
<A NAME="s5.2"><H2>5.2  Environmental considerations</H2></A>

<A NAME="s5.2.1"><H3>5.2.1  Character sets</H3></A>

This specification assumes the properties of the characters common to
the basic source and basic execution character sets that are stated in the
standard.
<A NAME="s5.2.1.1"><H4>5.2.1.1  Trigraph sequences</H4></A>

Not covered by this specification.
<A NAME="s5.2.1.2"><H4>5.2.1.2  Multibyte characters</H4></A>

Not covered by this specification.
<A NAME="s5.2.2"><H3>5.2.2  Character display semantics</H3></A>

The escapes described in this section are recognized by the processor, but
their effect in output text is beyond the scope of the specification.
<A NAME="s5.2.3"><H3>5.2.3  Signals and interrupts</H3></A>

Not covered by this specification.
<A NAME="s5.2.4"><H3>5.2.4  Environmental limits</H3></A>

The translation environment described by this specification does not
constrain the implementation.
<A NAME="s6"><H1>6  Language</H1></A>

In the syntactic notation used here, syntactic categories (nonterminals)
are indicated by words in <TT>this</TT> type, and literal words and character
set members (terminals) by enclosing them in apostrophes <TT>' '</TT>.
The underscore character <TT>_</TT> is used instead of the standard's hyphen
<TT>-</TT> within symbols.
A colon (<TT>:</TT>) following a nonterminal introduces its definition.
Alternative definitions are separated by slashes (<TT>/</TT>), and the
definition is terminated by a period.
An optional symbol is indicated by adding <TT>_opt</TT> to the name.
<P>
Optional symbols are defined implicitly in the standard, but explicit
definitions are required in order to generate a parser:
<BLOCKQUOTE>
<A NAME="m14"><I>Optional symbols</I>[14]</A>==<BLOCKQUOTE><PRE>
abstract_declarator_opt: / abstract_declarator .
constant_exp_opt: / constant_expression .
declaration_list_opt: empty / declaration_list .
member_declarator_opt: / member_declarator .
expression_opt: / expression .
identifier_list_opt: / identifier_list .
init_declarator_list_opt: / init_declarator_list .
parameter_type_list_opt: /
  <A HREF="#m186"><I>Prototype begin</I>[186]</A> <A HREF="#m194"><I>Begin a parameter_type_list</I>[194]</A> parameter_type_list
    <A HREF="#m195"><I>End a parameter_type_list</I>[195]</A> <A HREF="#m187"><I>Prototype end</I>[187]</A> .
statement_list_opt: / statement_list .

empty: .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


The symbol <TT>empty</TT> is used only in those cases where the attribution
rules require a tree node with a nonterminal child.
<A NAME="s6.1"><H2>6.1  Lexical elements</H2></A>

<BLOCKQUOTE>
<A NAME="m15"><I>Lexical elements</I>[15]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m16"><I>Identifiers</I>[16]</A>
<A HREF="#m44"><I>Floating constants</I>[44]</A>
<A HREF="#m48"><I>Integer constants</I>[48]</A>
<A HREF="#m52"><I>Character constants</I>[52]</A>
<A HREF="#m53"><I>String literals</I>[53]</A>
<A HREF="#m55"><I>Comments</I>[55]</A>
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m1">1</A>.
</BLOCKQUOTE>


<A NAME="s6.1.1"><H3>6.1.1  Keywords</H3></A>

Keywords are described by literal terminals in the grammar.
<A NAME="s6.1.2"><H3>6.1.2  Identifiers</H3></A>

<BLOCKQUOTE>
<A NAME="m16"><I>Identifiers</I>[16]</A>==<BLOCKQUOTE><PRE>
identifier:  $[_a-zA-Z][_a-zA-Z0-9]* [IdnOrType]
<A HREF="#m168"><I>Type definitions</I>[168]</A>
<A HREF="#m205"><I>Additional terminal symbols representing identifiers</I>[205]</A>
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m15">15</A>.
</BLOCKQUOTE>


The ambiguity resolution rules of Eli guarantee that every character
sequence satisfying this definition will be initially classified as an
<TT>identifier</TT>, and that the token processor <TT>IdnOrType</TT> will be invoked
after the character sequence has been recognized.
<TT>IdnOrType</TT> may then re-classify the sequence if that is appropriate.
<A NAME="s6.1.2.1"><H4>6.1.2.1  Scopes of identifiers</H4></A>

An identifier is <EM>visible</EM> (i.e., can be used) only within a region of
the program text called its <EM>scope</EM>.
There are four kinds of scopes: function, file, block and function
prototype.
<P>
A label name is the only kind of identifier that has <EM>function scope</EM>.
It can be used (in a <TT>goto</TT> statement) anywhere in the function in which
it appears, and is declared implicitly by its syntactic appearance followed
by a <TT>:</TT>.
Label names shall be unique within a function.
<P>
An instantiation of Eli's <TT>Unique</TT> module is used to verify that label
names must be unique within a function.
<BLOCKQUOTE>
<A NAME="m17"><I>Name analysis modules for label identifiers</I>[17]</A>==<BLOCKQUOTE><PRE>
$/Prop/Unique.gnrc +instance=Label +referto=Label :inst
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m10">10</A>.
</BLOCKQUOTE>


The <TT>Unique</TT> module exports two symbols: <TT>LabelUnique</TT> marks the nodes
representing the occurrences of the identifiers to be tested for uniqueness,
while <TT>LabelRangeUnique</TT> marks the subtree containing all of those nodes.
<BLOCKQUOTE>
<A NAME="m18"><I>Function scope</I>[18]</A>==<BLOCKQUOTE><PRE>
SYMBOL file                INHERITS LabelRootScope, LabelRangeUnique END;
SYMBOL function_definition INHERITS LabelRangeScope                  END;

RULE: jump_statement ::= 'goto' LabelUse ';' END;

SYMBOL LabelUse INHERITS LabelIdUseEnv COMPUTE
  IF(EQ(THIS.LabelKey,NoKey),
    message(ERROR, &quot;Label identifier is not defined&quot;, 0, COORDREF));
END;

RULE: labeled_statement ::= LabelDef ':' statement END;

SYMBOL LabelDef INHERITS LabelIdDefScope, LabelUnique COMPUTE
  IF(NOT(THIS.LabelUnique),
    message(ERROR, &quot;Label identifier is multiply defined&quot;, 0, COORDREF));
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


Every other identifier has a scope determined by the placement of its
declaration (in a declarator or type specifier).
If the declarator or type specifier that declares the identifier appears
outside of any block or list of parameters, the identifier has <EM>file
scope</EM>, which terminates at the end of the translation unit.
<BLOCKQUOTE>
<A NAME="m19"><I>File scope</I>[19]</A>==<BLOCKQUOTE><PRE>
SYMBOL file INHERITS TagRootScope END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


If the declarator or type specifier that declares the identifier appears
inside a block or within the list of parameter declarations in a function
definition, the identifier has <EM>block scope</EM>, which terminates at the
<TT>}</TT> that closes the associated block.
<BLOCKQUOTE>
<A NAME="m20"><I>Block scope</I>[20]</A>==<BLOCKQUOTE><PRE>
SYMBOL declaration_list_opt INHERITS TagRangeScope END;
SYMBOL compound_statement   INHERITS TagRangeScope END;
ATTR TagEnv: Environment;

RULE: function_definition ::=
  declaration_specifiers declarator declaration_list_opt compound_statement
COMPUTE
  <A HREF="#m21"><I>Block scope tag environment for a function definition</I>[21]</A>
END;

RULE: function_definition ::=
                         declarator declaration_list_opt compound_statement
COMPUTE
  <A HREF="#m21"><I>Block scope tag environment for a function definition</I>[21]</A>
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


In a <TT>function_definition</TT>, the <TT>declaration_list_opt</TT> and
<TT>compound_statement</TT> are parts of the same scope.
If a prototype is given for the function, that prototype is also part of
the scope.
<BLOCKQUOTE>
<A NAME="m21"><I>Block scope tag environment for a function definition</I>[21]</A>==<BLOCKQUOTE><PRE>
.TagEnv=
  declarator CONSTITUENTS parameter_part.TagEnv
    SHIELD (parameter_part, constant_exp_opt)
    WITH (Environment, Leftmost, IDENTICAL, NOENV);
declaration_list_opt.TagEnv=IF(EQ(.TagEnv, NoEnv), NewEnv(), .TagEnv);
compound_statement.TagEnv=declaration_list_opt.TagEnv;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m20">20</A>.
</BLOCKQUOTE>


A <TT>parameter_part</TT> phrase may contain nested <TT>parameter_part</TT> phrases,
which could not be the prototype of the function being called.
Thus the <TT>CONSTITUENTS</TT> process must be prevented from examining
components of <TT>parameter_part</TT> phrases.
On the other hand, it must examine nested <TT>declarator</TT> phrases because
the function and its prototype may be enclosed in parentheses.
The <TT>SHIELD</TT> clause has this effect, and also prevents the examination of
array size specifications (which cannot contain the function's prototype).
<P>
Even at the top level, however, a <TT>declarator</TT> may contain many
<TT>parameter_part</TT> phrases.
The one defining the parameters of the function is textually the leftmost,
so the <TT>WITH</TT> clause uses <TT>Leftmost</TT> to choose the leftmost non-null
environment.
<BLOCKQUOTE>
<A NAME="m22"><I>Computations for obtaining the tag environment from a declarator</I>[22]</A>==<BLOCKQUOTE><PRE>
#define Leftmost(x,y) ((x)==NoEnv?(y):(x))
#define NOENV() NoEnv
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m11">11</A>.
</BLOCKQUOTE>


If the declarator or type specifier that declares the identifier appears
within the list of parameter declarations in a function prototype (not part
of a function definition), the identifier has <EM>function prototype scope</EM>,
which terminates at the end of the function declarator.
<BLOCKQUOTE>
<A NAME="m23"><I>Function prototype scope</I>[23]</A>==<BLOCKQUOTE><PRE>
SYMBOL parameter_part INHERITS TagRangeScope END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


If an outer declaration of a lexically identical identifier exists in the
same name space, it is hidden until the current scope terminates, after
which it again becomes visible.
<P>
Two identifiers have the same scope if and only if their scopes terminate
at the same point.
<P>
Structure, union and enumeration tags have scope that begins just after the
appearance of the tag in a type specifier that declares the tag.
<BLOCKQUOTE>
<A NAME="m24"><I>Tag scope</I>[24]</A>==<BLOCKQUOTE><PRE>
SYMBOL TagDef INHERITS TagIdDefScope END;
SYMBOL TagUse INHERITS TagIdUseEnv   END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


Each enumeration constant has scope that begins just after the appearance
of the defining <TT>enumerator</TT> in an <TT>enumerator_list</TT>.
<BLOCKQUOTE>
<A NAME="m25"><I>enumerator</I>[25]</A>==<BLOCKQUOTE><PRE>
  enumerator <A HREF="#m223"><I>Carry out a deferred binding</I>[223]</A>
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m142">142</A>.
</BLOCKQUOTE>


Any other identifier has scope that begins just after the completion of its
declarator.
<BLOCKQUOTE>
<A NAME="m26"><I>Innermost declarator</I>[26]</A>==<BLOCKQUOTE><PRE>
  direct_declarator <A HREF="#m223"><I>Carry out a deferred binding</I>[223]</A>
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m153">153</A>.
</BLOCKQUOTE>


A <TT>typedef_name</TT> is an ordinary identifier, declared by a <TT>declaration</TT>
containing the <TT>storage_class_specifier</TT> ``typedef''.
The scopes of all ordinary identifiers must therefore be determined
during parsing in order to support <TT>IdnOrType</TT> in its task of classifying
character sequences recognized as <TT>identifier</TT>.
Only in this way is it possible to decide whether a particular use of an
ordinary identifier should be interpreted as a <TT>typedef_name</TT>.
<A NAME="s6.1.2.2"><H4>6.1.2.2  Linkages of identifiers</H4></A>

<A NAME="s6.1.2.3"><H4>6.1.2.3  Name spaces of identifiers</H4></A>

If more than one declaration of a particular identifier is visible at any
point in a translation unit, the syntactic context disambiguates uses that
refer to different entities.
Thus, there are separate <EM>name spaces</EM> for various categories of
identifiers, as follows:
<BLOCKQUOTE>
<A NAME="m27"><I>Name spaces of identifiers</I>[27]</A>==<BLOCKQUOTE><PRE>
$/Name/AlgScope.gnrc +instance=Label  +referto=Label  :inst
$/Name/CScope.gnrc   +instance=Tag    +referto=Tag    :inst
$/Name/CScope.gnrc   +instance=Member +referto=Member :inst
<A HREF="#m181"><I>Ordinary identifier name space</I>[181]</A>
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m10">10</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m28"><I>Disambiguation of member names</I>[28]</A>==<BLOCKQUOTE><PRE>
RULE: Expression ::= Expression '.' MemberIdUse END;
RULE: Expression ::= Expression '-&gt;' MemberIdUse END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


Ordinary identifiers must be renamed during parsing in order to avoid an
ambiguity in the grammar.
That process does not meet the preconditions for using any of the Eli name
analysis modules, and therefore must be handled with more primitive
operations.
The details are presented in a later chapter.
<BLOCKQUOTE>
<A NAME="m29"><I>component_list: </I>[29]</A>==<BLOCKQUOTE><PRE>
component_list:
  <A HREF="#m192"><I>Begin a component_list</I>[192]</A> '{' struct_declaration_list
  <A HREF="#m193"><I>End a component_list</I>[193]</A> '}' .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m138">138</A>.
</BLOCKQUOTE>


<A NAME="s6.1.2.4"><H4>6.1.2.4  Storage duration of objects</H4></A>

<A NAME="s6.1.2.5"><H4>6.1.2.5  Types</H4></A>

The meaning of a value stored in an object or returned by a function is
determined by the <EM>type</EM> of the expression used to access it.
(An identifier declared to be an object is the simplest such expression:
the type is specified in the declaration of the identifier.)
Types are partitioned into <EM>object types</EM> (types that describe objects),
<EM>function types</EM> (types that describe functions), and
<EM>incomplete types</EM> (types that describe objects but lack information
needed to determine their sizes).
<P>
This section introduces the OIL identifiers used to represent basic C types,
sets of types, and user-defined types.
All of these identifiers begin with <TT>TypeIs_</TT>.
Identifiers representing the basic types of C continue with one or more C
keywords, all lower case, giving the canonic name of the type in the standard
(e.g. <TT>TypeIs_char</TT>).
Identifiers representing sets of types and user-defined types continue with a
capitalized name.
That name is the one used by the standard to describe the set of types or
the derivation of the user-defined type wherever possible
(e.g. <TT>TypeIs_Integral</TT>, <TT>TypeIs_Pointer</TT>).
<P>
Sets of types are specified in this section by OIL <TT>SET</TT> directives.
<P>
The standard provides mechanisms for a user to define additional types.
Each of these mechanisms is specified in this section by an OIL <TT>CLASS</TT>.
<BLOCKQUOTE>
<A NAME="m30"><I>Types</I>[30]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m31"><I>Signed integer types</I>[31]</A>
<A HREF="#m32"><I>Unsigned integer types</I>[32]</A>
<A HREF="#m33"><I>Floating types</I>[33]</A>
<A HREF="#m40"><I>Integral types</I>[40]</A>
<A HREF="#m41"><I>Arithmetic types</I>[41]</A>
<A HREF="#m42"><I>Scalar types</I>[42]</A>
<A HREF="#m59"><I>Promoted types</I>[59]</A>
<A HREF="#m36"><I>Structure types</I>[36]</A>
<A HREF="#m37"><I>Union types</I>[37]</A>
<A HREF="#m34"><I>Enumeration types</I>[34]</A>
<A HREF="#m38"><I>Function type derivation</I>[38]</A>
<A HREF="#m35"><I>Array type derivation</I>[35]</A>
<A HREF="#m39"><I>Pointer type derivation</I>[39]</A>
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m5">5</A>.
</BLOCKQUOTE>


A <TT>TypeIs_char</TT> object is large enough to store any member of the basic
execution character set.
<P>
There are four <EM>signed integer types</EM>:
<BLOCKQUOTE>
<A NAME="m31"><I>Signed integer types</I>[31]</A>==<BLOCKQUOTE><PRE>
SET TypeIs_Signed_Integer=
  [TypeIs_signed_char, TypeIs_short, TypeIs_int, TypeIs_long];
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m30">30</A>.
</BLOCKQUOTE>


For each of the signed integer types, there is a corresponding (but
different) <EM>unsigned integer type</EM> that uses the same amount of storage
(including sign information) and has the same alignment requirements:
<BLOCKQUOTE>
<A NAME="m32"><I>Unsigned integer types</I>[32]</A>==<BLOCKQUOTE><PRE>
SET TypeIs_Unsigned_Integer=
  [TypeIs_unsigned_char, TypeIs_unsigned_short, TypeIs_unsigned_int,
   TypeIs_unsigned_long];
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m30">30</A>.
</BLOCKQUOTE>


There are three <EM>floating types</EM>:
<BLOCKQUOTE>
<A NAME="m33"><I>Floating types</I>[33]</A>==<BLOCKQUOTE><PRE>
SET TypeIs_Floating=
  [TypeIs_float, TypeIs_double, TypeIs_long_double];
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m30">30</A>.
</BLOCKQUOTE>


<TT>TypeIs_char</TT>, the signed and unsigned integer types, and the floating
types are collectively called the <EM>basic types</EM>.
Even if the implementation defines two or more basic types to have the same
representation, they are nevertheless different types.
<P>
An <EM>enumeration</EM> comprises a set of named integer constant values.
Each distinct enumeration constitutes a different <EM>enumerated type</EM>.
<BLOCKQUOTE>
<A NAME="m34"><I>Enumeration types</I>[34]</A>==<BLOCKQUOTE><PRE>
CLASS TypeIs_Enum() BEGIN
  <A HREF="#m58"><I>Enumeration conversion</I>[58]</A>
  <A HREF="#m122"><I>Operator defined for this enumeration type</I>[122]</A>
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m30">30</A>.
</BLOCKQUOTE>


<TT>TypeIs_void</TT> comprises an empty set of values; it is an incomplete type
that cannot be completed.
<P>
Any number of <EM>derived types</EM> can be constructed from the object,
function and incomplete types, as follows:
<P>
An <EM>array type</EM> describes a contiguously allocated nonempty set of
objects with a particular member object type, called the <EM>element type</EM>.
Array objects are characterized by their element type and by the number of
elements in the array.
An array type is said to be derived from its element type, and if its
element type is <TT>T</TT>, the array type is sometimes called ``array of
<TT>T</TT>''.
The construction of an array type from an element type is called ``array
type derivation''.
<BLOCKQUOTE>
<A NAME="m35"><I>Array type derivation</I>[35]</A>==<BLOCKQUOTE><PRE>
CLASS TypeIs_Array(elementType, pointerType) BEGIN
  <A HREF="#m62"><I>Array conversion</I>[62]</A>
  <A HREF="#m73"><I>Operators defined for this array type</I>[73]</A>
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m30">30</A>.
</BLOCKQUOTE>


A <EM>structure type</EM> describes a sequentially allocated nonempty set of
member objects, each of which has an optionally specified name and possibly
distinct type.
<BLOCKQUOTE>
<A NAME="m36"><I>Structure types</I>[36]</A>==<BLOCKQUOTE><PRE>
CLASS TypeIs_Struct() BEGIN
  <A HREF="#m120"><I>Operator defined for this struct type</I>[120]</A>
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m30">30</A>.
</BLOCKQUOTE>


A <EM>union type</EM> describes an overlapping nonempty set of member objects,
each of which has an optionally specified name and possibly distinct type.
<BLOCKQUOTE>
<A NAME="m37"><I>Union types</I>[37]</A>==<BLOCKQUOTE><PRE>
CLASS TypeIs_Union() BEGIN
  <A HREF="#m121"><I>Operator defined for this union type</I>[121]</A>
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m30">30</A>.
</BLOCKQUOTE>


A <EM>function type</EM> describes a function with a specified return type.
A function type is characterized by its return type and the number and
types of its parameters.
A function type is said to be derived from its return type, and if its
return type is <TT>T</TT>, the function type is sometimes called ``function
returning <TT>T</TT>''.
The construction of a function type from a return type is called ``function
type derivation''.
<BLOCKQUOTE>
<A NAME="m38"><I>Function type derivation</I>[38]</A>==<BLOCKQUOTE><PRE>
CLASS TypeIs_Function(returnType) BEGIN
  <A HREF="#m76"><I>Operators defined for this function type</I>[76]</A>
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m30">30</A>.
</BLOCKQUOTE>


A <EM>pointer type</EM> may be derived from a function type, an object type, or
an incomplete type, called the <EM>referenced type</EM>.
A pointer type describes an object whose value provides a reference to an
entity of the referenced type.
A pointer type derived from the referenced type <TT>T</TT> is sometimes called
``pointer to <TT>T</TT>''.
The construction of a pointer type from a referenced type is called
``pointer type derivation''.
<BLOCKQUOTE>
<A NAME="m39"><I>Pointer type derivation</I>[39]</A>==<BLOCKQUOTE><PRE>
CLASS TypeIs_Pointer(referencedType) BEGIN
  <A HREF="#m66"><I>Pointer</I>[66]</A>
  <A HREF="#m65"><I>Discard pointer values</I>[65]</A>
  <A HREF="#m68"><I>Null constant for this pointer type</I>[68]</A>
  <A HREF="#m74"><I>Operators defined for this pointer type</I>[74]</A>
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m30">30</A>.
</BLOCKQUOTE>


These methods of constructing types can be applied recursively.
<P>
The standard specifies that the representations of <EM>integral</EM>
objects shall define values by use of a pure binary numeration system:
<BLOCKQUOTE>
<A NAME="m40"><I>Integral types</I>[40]</A>==<BLOCKQUOTE><PRE>
SET TypeIs_Integral=
  [TypeIs_char] + TypeIs_Signed_Integer + TypeIs_Unsigned_Integer;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m30">30</A>.
</BLOCKQUOTE>


Enumerated types are considered to be integral also, but an OIL set
is a static object and therefore cannot contain a class as a member.
Each enumerated type must therefore be individually described as integral,
which is the effect of the integer promotions described below.
<P>
<EM>Arithmetic</EM> objects are those that can participate in
arithmetic operations:
<BLOCKQUOTE>
<A NAME="m41"><I>Arithmetic types</I>[41]</A>==<BLOCKQUOTE><PRE>
SET TypeIs_Arithmetic = TypeIs_Integral + TypeIs_Floating;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m30">30</A>.
</BLOCKQUOTE>


<EM>Scalar</EM> objects are those that can be compared with one another:
<BLOCKQUOTE>
<A NAME="m42"><I>Scalar types</I>[42]</A>==<BLOCKQUOTE><PRE>
SET TypeIs_Scalar = TypeIs_Arithmetic + [TypeIs_VoidPointer];
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m30">30</A>.
</BLOCKQUOTE>


Pointer types are considered to be scalar also, but an OIL set
is a static object and therefore cannot contain a class as a member.
Each pointer type must therefore be individually described as scalar,
which is the effect of the pointer conversions described below.
<A NAME="s6.1.2.6"><H4>6.1.2.6  Compatible type and composite type</H4></A>

<A NAME="s6.1.3"><H3>6.1.3  Constants</H3></A>

There is no <TT>enumeration_constant</TT> because an <TT>enumeration_constant</TT> is
recognized as an <TT>identifier</TT>.
If <TT>enumeration_constant</TT> appeared in this definition of <TT>constant</TT>,
there would be an LALR(1) conflict in the grammar.
<BLOCKQUOTE>
<A NAME="m43"><I>Constants</I>[43]</A>==<BLOCKQUOTE><PRE>
constant:
  floating_constant /
  integer_constant /
  character_constant .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<A NAME="s6.1.3.1"><H4>6.1.3.1  Floating constants</H4></A>

<BLOCKQUOTE>
<A NAME="m44"><I>Floating constants</I>[44]</A>==<BLOCKQUOTE><PRE>
floating_constant:  $(<A HREF="#m45"><I>F</I>[45]</A><A HREF="#m46"><I>E</I>[46]</A>?|<A HREF="#m47"><I>D</I>[47]</A>+<A HREF="#m46"><I>E</I>[46]</A>)[flFL]?   [mkidn]
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m15">15</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m45"><I>F</I>[45]</A>==<BLOCKQUOTE><PRE>(<A HREF="#m47"><I>D</I>[47]</A>*\.<A HREF="#m47"><I>D</I>[47]</A>+)</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m44">44</A>.
</BLOCKQUOTE>

<BLOCKQUOTE>
<A NAME="m46"><I>E</I>[46]</A>==<BLOCKQUOTE><PRE>([eE][+-]?<A HREF="#m47"><I>D</I>[47]</A>+)</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m44">44</A>.
</BLOCKQUOTE>

<BLOCKQUOTE>
<A NAME="m47"><I>D</I>[47]</A>==<BLOCKQUOTE><PRE>[0-9]</PRE></BLOCKQUOTE>
This macro is invoked in definitions <A HREF="#m44">44</A>, <A HREF="#m45">45</A>, <A HREF="#m46">46</A>, and <A HREF="#m48">48</A>.
</BLOCKQUOTE>


<A NAME="s6.1.3.2"><H4>6.1.3.2  Integer constants</H4></A>

<BLOCKQUOTE>
<A NAME="m48"><I>Integer constants</I>[48]</A>==<BLOCKQUOTE><PRE>
integer_constant:  $([1-9]<A HREF="#m47"><I>D</I>[47]</A>*|<A HREF="#m49"><I>O</I>[49]</A>|<A HREF="#m50"><I>H</I>[50]</A>)([uU][lL]?|[lL][uU]?)?   [c_mkint]
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m15">15</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m49"><I>O</I>[49]</A>==<BLOCKQUOTE><PRE>0[0-7]*</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m48">48</A>.
</BLOCKQUOTE>

<BLOCKQUOTE>
<A NAME="m50"><I>H</I>[50]</A>==<BLOCKQUOTE><PRE>0[xX][0-9a-fA-F]+</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m48">48</A>.
</BLOCKQUOTE>

<A NAME="s6.1.3.3"><H4>6.1.3.3  Enumeration constants</H4></A>

Enumeration constants are identifiers, so no additional lexical
specification is required.
<BLOCKQUOTE>
<A NAME="m51"><I>Enumeration constants</I>[51]</A>==<BLOCKQUOTE><PRE>
enumeration_constant: OrdinaryIdDef <A HREF="#m222"><I>Defer binding the declared identifier</I>[222]</A> .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<A NAME="s6.1.3.4"><H4>6.1.3.4  Character constants</H4></A>

C character denotations are defined by a canned description in Eli.
<BLOCKQUOTE>
<A NAME="m52"><I>Character constants</I>[52]</A>==<BLOCKQUOTE><PRE>
character_constant:  C_CHAR_CONSTANT
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m15">15</A>.
</BLOCKQUOTE>


<A NAME="s6.1.4"><H3>6.1.4  String literals</H3></A>

C string literals are defined by a canned description in Eli.
<BLOCKQUOTE>
<A NAME="m53"><I>String literals</I>[53]</A>==<BLOCKQUOTE><PRE>
string_literal:  C_STRING_LIT
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m15">15</A>.
</BLOCKQUOTE>


Sequences of string literals are translated as single strings.
By defining such a sequence as a <TT>StringSeq</TT>, we allow the specification
to use Eli's canned description of a single string literal.
<BLOCKQUOTE>
<A NAME="m54"><I>String sequence</I>[54]</A>==<BLOCKQUOTE><PRE>
StringSeq:
  string_literal /
  StringSeq string_literal .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<A NAME="s6.1.5"><H3>6.1.5  Operators</H3></A>

Operators are represented by literal symbols in the grammar, so no
additional lexical specification is necessary.
<A NAME="s6.1.6"><H3>6.1.6  Punctuators</H3></A>

Punctuators are represented by literal symbols in the grammar, so no
additional lexical specification is necessary.
<A NAME="s6.1.7"><H3>6.1.7  Header names</H3></A>

Preprocessing is not done within the generated compiler.
<A NAME="s6.1.8"><H3>6.1.8  Preprocessing numbers</H3></A>

Preprocessing is not done within the generated compiler.
<A NAME="s6.1.9"><H3>6.1.9  Comments</H3></A>

C comments are defined by a canned description in Eli.
<BLOCKQUOTE>
<A NAME="m55"><I>Comments</I>[55]</A>==<BLOCKQUOTE><PRE>
  C_COMMENT
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m15">15</A>.
</BLOCKQUOTE>


<A NAME="s6.2"><H2>6.2  Conversions</H2></A>

Several operators convert operands from one type to another automatically.
This subclause specifies the result required from such <EM>implicit conversion</EM>,
as well as those that result from a cast operation (an <EM>explicit
conversion</EM>).
<P>
Each implicit conversion is defined in this section by an OIL <TT>COERCION</TT>
specification.
<BLOCKQUOTE>
<A NAME="m56"><I>Implicit conversions</I>[56]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m57"><I>Characters and integers</I>[57]</A>
<A HREF="#m60"><I>Usual arithmetic conversions</I>[60]</A>
<A HREF="#m64"><I>void</I>[64]</A>
<A HREF="#m67"><I>Conversions for null pointer constants</I>[67]</A>
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m5">5</A>.
</BLOCKQUOTE>


The specifications in this section assume that objects of certain types are
capable of representing all of the values of other types.
Those assumptions are completely compatible with the standard, but may not
hold for a specific implementation of C.
If this type analysis module is being used in a translator, and the
assumptions do not hold, then the specifications must be changed as
indicated in the accompanying text.
<A NAME="s6.2.1"><H3>6.2.1  Arithmetic operands</H3></A>

<A NAME="s6.2.1.1"><H4>6.2.1.1  Characters and integers</H4></A>

A <TT>char</TT>, a <TT>short</TT>, or an <TT>int</TT> bit-field,
or their signed or unsigned varieties, or an enumeration type, may be used
in an expression wherever an <TT>int</TT> or <TT>unsigned int</TT>
may be used.
If a <TT>int</TT> can represent all values of the original type,
the value is converted to an <TT>int</TT>; otherwise,
it is converted to an <TT>unsigned int</TT>.
These are called the <EM>integral promotions</EM>.
All other arithmetic types are unchanged by the integral promotions.
<BLOCKQUOTE>
<A NAME="m57"><I>Characters and integers</I>[57]</A>==<BLOCKQUOTE><PRE>
COERCION CChartoInt(TypeIs_char): TypeIs_int;
COERCION CUnsignedChartoInt(TypeIs_unsigned_char): TypeIs_int;
COERCION CShorttoInt(TypeIs_short): TypeIs_int;
COERCION CUnsignedShorttoInt(TypeIs_unsigned_short): TypeIs_int;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m56">56</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m58"><I>Enumeration conversion</I>[58]</A>==<BLOCKQUOTE><PRE>
COERCION CEnumtoInt(TypeIs_Enum): TypeIs_int;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m34">34</A>.
</BLOCKQUOTE>


It may be necessary to alter these definitions based upon the
target machine if this module is to be used in a translator:
If an <TT>int</TT> object cannot represent all values of the argument
type, the result type for those conversions must be <TT>unsigned int</TT>.
<P>
Certain operators require that the integral promotion be performed on their
operand(s), and the result has the promoted type.
These operators are therefore defined in terms of sets that include only
promoted integer types:
<BLOCKQUOTE>
<A NAME="m59"><I>Promoted types</I>[59]</A>==<BLOCKQUOTE><PRE>
SET TypeIs_IntegralPromoted=
  [TypeIs_int, TypeIs_unsigned_int, TypeIs_long, TypeIs_unsigned_long];
SET TypeIs_ArithPromoted = TypeIs_IntegralPromoted + TypeIs_Floating;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m30">30</A>.
</BLOCKQUOTE>


<A NAME="s6.2.1.2"><H4>6.2.1.2  Signed and unsigned integers</H4></A>

<A NAME="s6.2.1.3"><H4>6.2.1.3  Floating and integral</H4></A>

<A NAME="s6.2.1.4"><H4>6.2.1.4  Floating types</H4></A>

<A NAME="s6.2.1.5"><H4>6.2.1.5  Usual arithmetic conversions</H4></A>

Many binary operators that expect operands of arithmetic type cause
conversions and yield result types in a similar way.
The purpose is to yield a common type, which is also the type of the
result.
This pattern is called the <EM>usual arithmetic conversions</EM>.
<BLOCKQUOTE>
<A NAME="m60"><I>Usual arithmetic conversions</I>[60]</A>==<BLOCKQUOTE><PRE>
COERCION CDoubletoLongDouble(TypeIs_double): TypeIs_long_double;
COERCION CFloattoDouble(TypeIs_float): TypeIs_double;
COERCION CUnsignedLongtoFloat(TypeIs_unsigned_long): TypeIs_float;
<A HREF="#m61"><I>Integer conversions</I>[61]</A>
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m56">56</A>.
</BLOCKQUOTE>


If both operands are integral, then integral promotions are performed on
them.
Then the following rules are applied:
<BLOCKQUOTE>
<A NAME="m61"><I>Integer conversions</I>[61]</A>==<BLOCKQUOTE><PRE>
COERCION CLongtoUnsignedLong(TypeIs_long): TypeIs_unsigned_long;
COERCION CUnsignedInttoLong(TypeIs_unsigned_int): TypeIs_long;
COERCION CInttoLong(TypeIs_int): TypeIs_long;
COERCION CInttoUnsignedInt(TypeIs_int): TypeIs_unsigned_int;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m60">60</A>.
</BLOCKQUOTE>


It may be necessary to alter the definition of <TT>CUnsignedInttoLong</TT> based
upon the target machine if this module is to be used in a translator:
If a <TT>TypeIs_long</TT> object cannot represent all values of type
<TT>TypeIs_unsigned_int</TT> the result type must be <TT>TypeIs_unsigned_long</TT>.
<A NAME="s6.2.2"><H3>6.2.2  Other operands</H3></A>

<A NAME="s6.2.2.1"><H4>6.2.2.1  Lvalues and function designators</H4></A>

Except when it is the operand of the <TT>sizeof</TT> operator or the unary <TT>&amp;</TT>
operator, or is a character string literal used to initialize an array of
character type, or is a wide string literal used to initialize an array
with element type compatible with <TT>wchar_t</TT>, an lvalue that has type
``array of <EM>type</EM>'' is converted to an expression that has type ``pointer
to <EM>type</EM>'' that points to the initial element of the array and is not an
lvalue.
<BLOCKQUOTE>
<A NAME="m62"><I>Array conversion</I>[62]</A>==<BLOCKQUOTE><PRE>
COERCION CArraytoPtr (TypeIs_Array): pointerType;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m35">35</A>.
</BLOCKQUOTE>


Except when it is the operand of the <TT>sizeof</TT> operator or the unary <TT>&amp;</TT>
operator, a function designator with type ``function returning <EM>type</EM>''
is converted to an expression that has type ``pointer to function returning
<EM>type</EM>''.
<BLOCKQUOTE>
<A NAME="m63"><I>Function conversion operator</I>[63]</A>==<BLOCKQUOTE><PRE>
CFunctoPtr;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m9">9</A>.
</BLOCKQUOTE>


<A NAME="s6.2.2.2"><H4>6.2.2.2  void</H4></A>

The (nonexistent) value of a <EM>void expression</EM> (an expression that has
<TT>TypeIs_void</TT>) shall not be used in any way, and implicit or explicit
conversions (except to <TT>TypeIs_void</TT>) shall not be applied to such an
expression.
If an expression of any other type occurs in a context where a void
expression is required, its value or designator is discarded.
(A void expression is evaluated for its side effects.)
<BLOCKQUOTE>
<A NAME="m64"><I>void</I>[64]</A>==<BLOCKQUOTE><PRE>
COERCION CScalartoVoid(TypeIs_Scalar): TypeIs_void;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m56">56</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m65"><I>Discard pointer values</I>[65]</A>==<BLOCKQUOTE><PRE>
COERCION CPtrtoVoid(TypeIs_Pointer): TypeIs_void;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m39">39</A>.
</BLOCKQUOTE>


<A NAME="s6.2.2.3"><H4>6.2.2.3  Pointer</H4></A>

A <TT>TypeIs_VoidPointer</TT> may be converted to or from a pointer to any
incomplete or object type.
In this specification, the conversion to a <TT>TypeIs_VoidPointer</TT> may be
either implicit or explicit; the conversion from <TT>TypeIs_VoidPointer</TT>
must be explicit.
<BLOCKQUOTE>
<A NAME="m66"><I>Pointer</I>[66]</A>==<BLOCKQUOTE><PRE>
COERCION CVoidPtr(TypeIs_Pointer): TypeIs_VoidPointer;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m39">39</A>.
</BLOCKQUOTE>


An integral constant expression with the value 0, or such an expression
cast to <TT>TypeIs_VoidPointer</TT>, is called a <EM>null pointer constant</EM>.
If a null pointer constant is assigned to or compared for equality to a
pointer, the constant is converted to a pointer of that type.
Such a pointer, called a <EM>null pointer</EM>, is guaranteed to compare unequal to
a pointer to any object or function.
A null pointer constant has <TT>TypeIs_NULL</TT>.
<BLOCKQUOTE>
<A NAME="m67"><I>Conversions for null pointer constants</I>[67]</A>==<BLOCKQUOTE><PRE>
COERCION CNulltoVoidPtr(TypeIs_NULL): TypeIs_VoidPointer;
COERCION CNulltoIntegral(TypeIs_NULL): TypeIs_Integral;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m56">56</A>.
</BLOCKQUOTE>


(The implicit conversion <TT>CNulltoIntegral</TT> is required to allow an
integral constant expression with the value 0 to be interpreted as an
integral value rather than a null pointer.)
<BLOCKQUOTE>
<A NAME="m68"><I>Null constant for this pointer type</I>[68]</A>==<BLOCKQUOTE><PRE>
COERCION CNulltoPtr(TypeIs_NULL): TypeIs_Pointer;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m39">39</A>.
</BLOCKQUOTE>


<A NAME="s6.3"><H2>6.3  Expressions</H2></A>

A C expression is a construct that yields a value.
The standard distinguishes expressions on the basis of the precedence of
that expression's operator.
This is done both to simplify the explanation of the meaning of an
expression and to preserve the context in which an expression occurs so
that the language's precedence and association rules are obeyed.
By describing the expressions in this way, the standard avoids the need to
discuss the concepts of precedence and association directly.
<P>
Precedence and association are only interesting because they relate the
structure of the program tree to the linear representation of the text.
Once the tree has been built, the operands of an operator are reflected in
the tree structure and there is no longer any need to distinguish different
kinds of expression.
Thus we define an equivalence class consisting of all of the symbols used
by the standard to name expressions:
<BLOCKQUOTE>
<A NAME="m69"><I>Expressions</I>[69]</A>==<BLOCKQUOTE><PRE>
Expression ::=
  primary_expression postfix_expression unary_expression cast_expression
  multiplicative_expression additive_expression shift_expression
  relational_expression equality_expression AND_expression
  exclusive_OR_expression inclusive_OR_expression logical_AND_expression
  logical_OR_expression conditional_expression assignment_expression
  constant_expression expression expression_opt .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m3">3</A>.
</BLOCKQUOTE>


Any symbol in this equivalence class will be represented in the tree by a
node with the name <TT>Expression</TT>, which is a new symbol not appearing
anywhere in the grammar.
<A NAME="s6.3.1"><H3>6.3.1  Primary expressions</H3></A>

<TT>IdUse</TT> replaces the symbol <TT>identifier</TT> appearing in the standard's
definition of a <TT>primary_expression</TT>.
As discussed in Section 1.1.2 above, <TT>IdUse</TT> makes the syntactic context
of an ordinary identifier use explicit.
<P>
<TT>StringSeq</TT> replaces the symbol <TT>string_literal</TT> appearing in the
standard's definition of a <TT>primary_expression</TT>.
As discussed in Section 1.1.4 above, <TT>StringSeq</TT> embodies the semantic
condition that a sequence of string literals is considered to be a single
string literal in C.
<BLOCKQUOTE>
<A NAME="m70"><I>Primary expressions</I>[70]</A>==<BLOCKQUOTE><PRE>
primary_expression:
  IdUse /
  constant /
  StringSeq /
  '(' expression ')' .

IdUse:
  UnboundIdUse /
  OrdinaryIdUse .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<A NAME="s6.3.2"><H3>6.3.2  Postfix operators</H3></A>

<BLOCKQUOTE>
<A NAME="m71"><I>Postfix operators</I>[71]</A>==<BLOCKQUOTE><PRE>
postfix_expression:
  primary_expression /
  postfix_expression '[' expression ']' /
  postfix_expression '(' argument_exp_list ')' /
  postfix_expression '('  ')' /
  postfix_expression '.' identifier /
  postfix_expression '-&gt;' identifier /
  postfix_expression '++' /
  postfix_expression '--' .

argument_exp_list:
  assignment_expression /
  argument_exp_list ',' assignment_expression.
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<A NAME="s6.3.2.1"><H4>6.3.2.1  Array subscripting</H4></A>

<BLOCKQUOTE>
<A NAME="m72"><I>Array subscripting</I>[72]</A>==<BLOCKQUOTE><PRE>
INDICATION Subscript_Indication: Subscript_Op, Array_Subscript_Op;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m5">5</A>.
</BLOCKQUOTE>


Distinct subscripting operations are defined for each array type and
each pointer type other than <TT>TypeIs_VoidPointer</TT>.
The second operand is specified to be a <TT>TypeIs_unsigned_long</TT>, although
the standard specifies that it has integral type.
Any integral type can be converted to <TT>TypeIs_unsigned_long</TT> by means of
implicit conversions, so this specification is equivalent to that of the
standard.
The main reason for using <TT>TypeIs_unsigned_long</TT> is that OIL does not
permit sets as operand specifications within a class definition, but a
secondary reason is that this approach reduces the total number of
operators in the compiler's database.
<BLOCKQUOTE>
<A NAME="m73"><I>Operators defined for this array type</I>[73]</A>==<BLOCKQUOTE><PRE>
OPER Array_Subscript_Op(TypeIs_Array, TypeIs_unsigned_long): elementType;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m73">73</A> and <A HREF="#m118">118</A>.<BR>
This macro is invoked in definition <A HREF="#m35">35</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m74"><I>Operators defined for this pointer type</I>[74]</A>==<BLOCKQUOTE><PRE>
OPER Subscript_Op(TypeIs_Pointer, TypeIs_unsigned_long): referencedType;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m74">74</A>, <A HREF="#m78">78</A>, <A HREF="#m81">81</A>, <A HREF="#m83">83</A>, <A HREF="#m86">86</A>, <A HREF="#m91">91</A>, <A HREF="#m96">96</A>, <A HREF="#m99">99</A>, <A HREF="#m108">108</A>, <A HREF="#m111">111</A>, <A HREF="#m114">114</A>, <A HREF="#m119">119</A>, and <A HREF="#m124">124</A>.<BR>
This macro is invoked in definition <A HREF="#m39">39</A>.
</BLOCKQUOTE>


<A NAME="s6.3.2.2"><H4>6.3.2.2  Function calls</H4></A>

<BLOCKQUOTE>
<A NAME="m75"><I>Function calls</I>[75]</A>==<BLOCKQUOTE><PRE>
INDICATION Call_Indication: FunCall_Op;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m5">5</A>.
</BLOCKQUOTE>


A distinct call operator is defined for each function type.
<BLOCKQUOTE>
<A NAME="m76"><I>Operators defined for this function type</I>[76]</A>==<BLOCKQUOTE><PRE>
OPER FunCall_Op(TypeIs_Function): returnType;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m38">38</A>.
</BLOCKQUOTE>


<A NAME="s6.3.2.3"><H4>6.3.2.3  Postfix increment and decrement operators</H4></A>

<BLOCKQUOTE>
<A NAME="m77"><I>Postfix increment and decrement operators</I>[77]</A>==<BLOCKQUOTE><PRE>
INDICATION Increment_Indication: Increment_Op, Ptr_Inc_Op;
INDICATION Decrement_Indication: Decrement_Op, Ptr_Dec_Op;
OPER Increment_Op, Decrement_Op(TypeIs_Arithmetic): TypeIs_Arithmetic;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m5">5</A>.
</BLOCKQUOTE>


Distinct increment and decrement operators are defined for each pointer
type other than <TT>TypeIs_VoidPointer</TT>.
<BLOCKQUOTE>
<A NAME="m78"><I>Operators defined for this pointer type</I>[78]</A>==<BLOCKQUOTE><PRE>
OPER Ptr_Inc_Op, Ptr_Dec_Op(TypeIs_Pointer): TypeIs_Pointer;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m74">74</A>, <A HREF="#m78">78</A>, <A HREF="#m81">81</A>, <A HREF="#m83">83</A>, <A HREF="#m86">86</A>, <A HREF="#m91">91</A>, <A HREF="#m96">96</A>, <A HREF="#m99">99</A>, <A HREF="#m108">108</A>, <A HREF="#m111">111</A>, <A HREF="#m114">114</A>, <A HREF="#m119">119</A>, and <A HREF="#m124">124</A>.<BR>
This macro is invoked in definition <A HREF="#m39">39</A>.
</BLOCKQUOTE>


<A NAME="s6.3.3"><H3>6.3.3  Unary operators</H3></A>

<BLOCKQUOTE>
<A NAME="m79"><I>Unary operators</I>[79]</A>==<BLOCKQUOTE><PRE>
unary_expression:
  postfix_expression /
  '++' unary_expression /
  '--' unary_expression /
  unary_operator cast_expression /
  'sizeof' unary_expression /
  'sizeof' '(' type_name ')'.

unary_operator:
  '&amp;' / '*' / '+' / '-' / '~' / '!'.
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<A NAME="s6.3.3.1"><H4>6.3.3.1  Prefix increment and decrement operators</H4></A>

No distinctions are made in this specification between the prefix and
postfix operations.
The only difference in semantics lies in their relationship to the
reference.
<A NAME="s6.3.3.2"><H4>6.3.3.2  Address and indirection operators</H4></A>

<BLOCKQUOTE>
<A NAME="m80"><I>Address and indirection operators</I>[80]</A>==<BLOCKQUOTE><PRE>
INDICATION Dereference_Indication: Ptr_Deref_Op;
INDICATION Reference_Indication: Ptr_Ref_Op;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m5">5</A>.
</BLOCKQUOTE>


A distinct indirection operator is defined for each pointer
type other than <TT>TypeIs_VoidPointer</TT>.
<BLOCKQUOTE>
<A NAME="m81"><I>Operators defined for this pointer type</I>[81]</A>==<BLOCKQUOTE><PRE>
OPER Ptr_Deref_Op(TypeIs_Pointer): referencedType;
OPER Ptr_Ref_Op(referencedType): TypeIs_Pointer;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m74">74</A>, <A HREF="#m78">78</A>, <A HREF="#m81">81</A>, <A HREF="#m83">83</A>, <A HREF="#m86">86</A>, <A HREF="#m91">91</A>, <A HREF="#m96">96</A>, <A HREF="#m99">99</A>, <A HREF="#m108">108</A>, <A HREF="#m111">111</A>, <A HREF="#m114">114</A>, <A HREF="#m119">119</A>, and <A HREF="#m124">124</A>.<BR>
This macro is invoked in definition <A HREF="#m39">39</A>.
</BLOCKQUOTE>


<A NAME="s6.3.3.3"><H4>6.3.3.3  Unary arithmetic operators</H4></A>

<BLOCKQUOTE>
<A NAME="m82"><I>Unary arithmetic operators</I>[82]</A>==<BLOCKQUOTE><PRE>
INDICATION Plus_Indication: Plus_Op;
INDICATION Minus_Indication: Minus_Op;
INDICATION Bitwise_Not_Indication: Bitwise_Not_Op;
INDICATION Not_Indication: Not_Op, Void_Ptr_Not_Op, Ptr_Not_Op;
OPER Plus_Op, Minus_Op(TypeIs_ArithPromoted): TypeIs_ArithPromoted;
OPER Bitwise_Not_Op(TypeIs_IntegralPromoted): TypeIs_IntegralPromoted;
OPER Not_Op(TypeIs_Scalar): TypeIs_int;
OPER Void_Ptr_Not_Op (TypeIs_VoidPointer): TypeIs_int;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m5">5</A>.
</BLOCKQUOTE>


A distinct logical negation operator is defined for each pointer
type other than <TT>TypeIs_VoidPointer</TT>.
<BLOCKQUOTE>
<A NAME="m83"><I>Operators defined for this pointer type</I>[83]</A>==<BLOCKQUOTE><PRE>
OPER Ptr_Not_Op (TypeIs_Pointer): TypeIs_int;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m74">74</A>, <A HREF="#m78">78</A>, <A HREF="#m81">81</A>, <A HREF="#m83">83</A>, <A HREF="#m86">86</A>, <A HREF="#m91">91</A>, <A HREF="#m96">96</A>, <A HREF="#m99">99</A>, <A HREF="#m108">108</A>, <A HREF="#m111">111</A>, <A HREF="#m114">114</A>, <A HREF="#m119">119</A>, and <A HREF="#m124">124</A>.<BR>
This macro is invoked in definition <A HREF="#m39">39</A>.
</BLOCKQUOTE>


<A NAME="s6.3.4"><H3>6.3.4  Cast operators</H3></A>

<BLOCKQUOTE>
<A NAME="m84"><I>Cast operators</I>[84]</A>==<BLOCKQUOTE><PRE>
cast_expression:
  unary_expression /
  '(' type_name ')' cast_expression.
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m85"><I>Cast operator semantics</I>[85]</A>==<BLOCKQUOTE><PRE>
INDICATION Cast_Indication: Cast_Op, Cast_IntegraltoPtr, Cast_VoidPtrtoPtr;

SET TypeIs_CastResult = TypeIs_Scalar;
OPER Cast_Op(TypeIs_Scalar): TypeIs_CastResult;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m5">5</A>.
</BLOCKQUOTE>


By defining <TT>TypeIs_CastResult</TT> as being equal to <TT>TypeIs_Scalar</TT> and
then using these two set identifiers in defining <TT>Cast_Op</TT>, the
specification defines a cast from every element of <TT>TypeIs_Scalar</TT> to
every other element of <TT>TypeIs_Scalar</TT>.
If <TT>Cast_Op</TT> were defined with the signature <TT>(TypeIs_Scalar):
TypeIs_Scalar</TT> then the operand and result would be constrained to be
identical.
<P>
The definition of <TT>Cast_Op</TT> allows any pointer type to be cast
to any integral type:
There is an implicit conversion from any pointer type to
<TT>TypeIs_VoidPointer</TT>, which is an element of <TT>TypeIs_Scalar</TT>, and
every integral type is an element of <TT>TypeIs_CastResult</TT>.
<P>
Distinct cast operators are defined for each pointer
type other than <TT>TypeIs_VoidPointer</TT> to handle casts from
arbitrary integers and from <TT>TypeIs_VoidPointer</TT> to that pointer type.
The operand of the former is specified to be a <TT>TypeIs_unsigned_long</TT>,
although the standard specifies that it has integral type.
Any integral type can be converted to <TT>TypeIs_unsigned_long</TT> by means of
implicit conversions, so this specification is equivalent to that of the
standard.
The main reason for using <TT>TypeIs_unsigned_long</TT> is that OIL does not
permit sets as operand specifications within a class definition, but a
secondary reason is that this approach reduces the total number of
operators in the compiler's database.
<BLOCKQUOTE>
<A NAME="m86"><I>Operators defined for this pointer type</I>[86]</A>==<BLOCKQUOTE><PRE>
OPER Cast_IntegraltoPtr(TypeIs_unsigned_long): TypeIs_Pointer;
OPER Cast_VoidPtrtoPtr(TypeIs_VoidPointer): TypeIs_Pointer;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m74">74</A>, <A HREF="#m78">78</A>, <A HREF="#m81">81</A>, <A HREF="#m83">83</A>, <A HREF="#m86">86</A>, <A HREF="#m91">91</A>, <A HREF="#m96">96</A>, <A HREF="#m99">99</A>, <A HREF="#m108">108</A>, <A HREF="#m111">111</A>, <A HREF="#m114">114</A>, <A HREF="#m119">119</A>, and <A HREF="#m124">124</A>.<BR>
This macro is invoked in definition <A HREF="#m39">39</A>.
</BLOCKQUOTE>


The implicit conversion from any pointer type to <TT>TypeIs_VoidPointer</TT>,
combined with <TT>Cast_VoidPtrtoPtr</TT>, allows any pointer type to be cast to
any other pointer type.
(This includes pointers to function types.)
<A NAME="s6.3.5"><H3>6.3.5  Multiplicative operators</H3></A>

<BLOCKQUOTE>
<A NAME="m87"><I>Multiplicative operators</I>[87]</A>==<BLOCKQUOTE><PRE>
multiplicative_expression:
  cast_expression /
  multiplicative_expression '*' cast_expression /
  multiplicative_expression '/' cast_expression /
  multiplicative_expression '%' cast_expression .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m88"><I>Multiplicative operator semantics</I>[88]</A>==<BLOCKQUOTE><PRE>
INDICATION Multiplication_Indication: MulOp;
INDICATION Division_Indication: DivOp;
INDICATION Mod_Indication: ModOp;
OPER MulOp, DivOp(TypeIs_Arithmetic, TypeIs_Arithmetic): TypeIs_Arithmetic;
OPER ModOp(TypeIs_Integral, TypeIs_Integral): TypeIs_Integral;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m5">5</A>.
</BLOCKQUOTE>


<A NAME="s6.3.6"><H3>6.3.6  Additive operators</H3></A>

<BLOCKQUOTE>
<A NAME="m89"><I>Additive operators</I>[89]</A>==<BLOCKQUOTE><PRE>
additive_expression:
  multiplicative_expression /
  additive_expression '+' multiplicative_expression /
  additive_expression '-' multiplicative_expression .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m90"><I>Additive operator semantics</I>[90]</A>==<BLOCKQUOTE><PRE>
INDICATION Addition_Indication:
  AddOp, Void_Ptr_Add_Op, Void_Ptr_Rev_Add_Op, Ptr_Add_Op, Ptr_Rev_Add_Op;
INDICATION Subtraction_Indication:
  SubOp, Void_Ptr_Sub_Op, Ptr_Sub_Op, Ptr_Ptr_Sub_Op;
OPER AddOp, SubOp(TypeIs_Arithmetic, TypeIs_Arithmetic): TypeIs_Arithmetic;
OPER
  Void_Ptr_Add_Op, Void_Ptr_Sub_Op(TypeIs_VoidPointer, TypeIs_unsigned_long):
    TypeIs_VoidPointer;
OPER
  Void_Ptr_Rev_Add_Op(TypeIs_unsigned_long, TypeIs_VoidPointer):
    TypeIs_VoidPointer;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m5">5</A>.
</BLOCKQUOTE>


Distinct additive operators are defined for each pointer
type other than <TT>TypeIs_VoidPointer</TT>.
<BLOCKQUOTE>
<A NAME="m91"><I>Operators defined for this pointer type</I>[91]</A>==<BLOCKQUOTE><PRE>
OPER
  Ptr_Add_Op, Ptr_Sub_Op(TypeIs_Pointer, TypeIs_unsigned_long): TypeIs_Pointer;
OPER
  Ptr_Rev_Add_Op, Ptr_Rev_Sub_Op(TypeIs_unsigned_long, TypeIs_Pointer):
    TypeIs_Pointer;
OPER Ptr_Ptr_Sub_Op(TypeIs_Pointer, TypeIs_Pointer): TypeIs_unsigned_long;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m74">74</A>, <A HREF="#m78">78</A>, <A HREF="#m81">81</A>, <A HREF="#m83">83</A>, <A HREF="#m86">86</A>, <A HREF="#m91">91</A>, <A HREF="#m96">96</A>, <A HREF="#m99">99</A>, <A HREF="#m108">108</A>, <A HREF="#m111">111</A>, <A HREF="#m114">114</A>, <A HREF="#m119">119</A>, and <A HREF="#m124">124</A>.<BR>
This macro is invoked in definition <A HREF="#m39">39</A>.
</BLOCKQUOTE>


The integral operand of an additive operator involving a pointer and an
integer is specified to be a <TT>TypeIs_unsigned_long</TT>.
Any integral type can be converted to <TT>TypeIs_unsigned_long</TT> by means of
implicit conversions, so this specification is equivalent to that of the
standard.
The main reason for using <TT>TypeIs_unsigned_long</TT> is that OIL does not
permit sets as operand specifications within a class definition, but a
secondary reason is that this approach reduces the total number of
operators in the compiler's database.
<A NAME="s6.3.7"><H3>6.3.7  Bitwise shift operators</H3></A>

<BLOCKQUOTE>
<A NAME="m92"><I>Bitwise shift operators</I>[92]</A>==<BLOCKQUOTE><PRE>
shift_expression:
  additive_expression /
  shift_expression '&lt;&lt;' additive_expression /
  shift_expression '&gt;&gt;' additive_expression .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m93"><I>Bitwise shift operator semantics</I>[93]</A>==<BLOCKQUOTE><PRE>
INDICATION Bit_Shift_Left_Indication: Bit_Shift_Left_Op;
INDICATION Bit_Shift_Right_Indication: Bit_Shift_Right_Op;

SET TypeIs_ShiftCount = TypeIs_IntegralPromoted;
OPER Bit_Shift_Right_Op, Bit_Shift_Left_Op
  (TypeIs_IntegralPromoted, TypeIs_ShiftCount): TypeIs_IntegralPromoted;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m5">5</A>.
</BLOCKQUOTE>


By defining <TT>TypeIs_ShiftCount</TT> as being equal to
<TT>TypeIs_IntegralPromoted</TT> and then using these two set identifiers
in defining the bitwise shift operators, the
specification allows different types of operands for the shift count and
the value being shifted.
The type of the result is that of the promoted left operand.
<A NAME="s6.3.8"><H3>6.3.8  Relational operators</H3></A>

<BLOCKQUOTE>
<A NAME="m94"><I>Relational operators</I>[94]</A>==<BLOCKQUOTE><PRE>
relational_expression:
  shift_expression /
  relational_expression '&lt;'  shift_expression /
  relational_expression '&gt;'  shift_expression /
  relational_expression '&lt;=' shift_expression /
  relational_expression '&gt;=' shift_expression .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m95"><I>Relational operator semantics</I>[95]</A>==<BLOCKQUOTE><PRE>
INDICATION LessThan_Indication: LessThan_Op, Ptr_LT_Op;
INDICATION Greater_Indication: Greater_Op, Ptr_GT_Op;
INDICATION LessThan_Equal_Indication: LessThan_Equal_Op, Ptr_LTE_Op;
INDICATION Greater_Equal_Indication: Greater_Equal_Op, Ptr_GTE_Op;
OPER Greater_Op, LessThan_Op, Greater_Equal_Op, LessThan_Equal_Op
  (TypeIs_Scalar, TypeIs_Scalar): TypeIs_int;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m5">5</A>.
</BLOCKQUOTE>


Distinct relational operators are defined for each pointer
type other than <TT>TypeIs_VoidPointer</TT>.
<BLOCKQUOTE>
<A NAME="m96"><I>Operators defined for this pointer type</I>[96]</A>==<BLOCKQUOTE><PRE>
OPER Ptr_LT_Op, Ptr_GT_Op, Ptr_LTE_Op, Ptr_GTE_Op
  (TypeIs_Pointer, TypeIs_Pointer): TypeIs_int;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m74">74</A>, <A HREF="#m78">78</A>, <A HREF="#m81">81</A>, <A HREF="#m83">83</A>, <A HREF="#m86">86</A>, <A HREF="#m91">91</A>, <A HREF="#m96">96</A>, <A HREF="#m99">99</A>, <A HREF="#m108">108</A>, <A HREF="#m111">111</A>, <A HREF="#m114">114</A>, <A HREF="#m119">119</A>, and <A HREF="#m124">124</A>.<BR>
This macro is invoked in definition <A HREF="#m39">39</A>.
</BLOCKQUOTE>


<A NAME="s6.3.9"><H3>6.3.9  Equality operators</H3></A>

<BLOCKQUOTE>
<A NAME="m97"><I>Equality operators</I>[97]</A>==<BLOCKQUOTE><PRE>
equality_expression:
  relational_expression /
  equality_expression '==' relational_expression /
  equality_expression '!=' relational_expression .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m98"><I>Equality operator semantics</I>[98]</A>==<BLOCKQUOTE><PRE>
INDICATION Equality_Indication: Equality_Op, Ptr_Eq_Op;
INDICATION Not_Equal_Indication: Not_Equal_Op, Ptr_NEq_Op;
OPER Equality_Op, Not_Equal_Op(TypeIs_Scalar, TypeIs_Scalar): TypeIs_int;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m5">5</A>.
</BLOCKQUOTE>


Distinct equality operators are defined for each pointer
type other than <TT>TypeIs_VoidPointer</TT>.
<BLOCKQUOTE>
<A NAME="m99"><I>Operators defined for this pointer type</I>[99]</A>==<BLOCKQUOTE><PRE>
OPER Ptr_Eq_Op, Ptr_NEq_Op(TypeIs_Pointer, TypeIs_Pointer): TypeIs_int;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m74">74</A>, <A HREF="#m78">78</A>, <A HREF="#m81">81</A>, <A HREF="#m83">83</A>, <A HREF="#m86">86</A>, <A HREF="#m91">91</A>, <A HREF="#m96">96</A>, <A HREF="#m99">99</A>, <A HREF="#m108">108</A>, <A HREF="#m111">111</A>, <A HREF="#m114">114</A>, <A HREF="#m119">119</A>, and <A HREF="#m124">124</A>.<BR>
This macro is invoked in definition <A HREF="#m39">39</A>.
</BLOCKQUOTE>


<A NAME="s6.3.10"><H3>6.3.10  Bitwise AND operator</H3></A>

<BLOCKQUOTE>
<A NAME="m100"><I>Bitwise AND operator</I>[100]</A>==<BLOCKQUOTE><PRE>
AND_expression:
  equality_expression /
  AND_expression '&amp;' equality_expression.
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m101"><I>Bitwise AND operator semantics</I>[101]</A>==<BLOCKQUOTE><PRE>
INDICATION Bitwise_And_Indication: Bitwise_And_Op;
OPER Bitwise_And_Op(TypeIs_Integral, TypeIs_Integral): TypeIs_Integral;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m5">5</A>.
</BLOCKQUOTE>


<A NAME="s6.3.11"><H3>6.3.11  Bitwise exclusive OR operator</H3></A>

<BLOCKQUOTE>
<A NAME="m102"><I>Bitwise exclusive OR operator</I>[102]</A>==<BLOCKQUOTE><PRE>
exclusive_OR_expression:
  AND_expression /
  exclusive_OR_expression '^' AND_expression.
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m103"><I>Bitwise exclusive OR operator semantics</I>[103]</A>==<BLOCKQUOTE><PRE>
INDICATION Bitwise_XOr_Indication: Bitwise_XOr_Op;
OPER Bitwise_XOr_Op(TypeIs_Integral, TypeIs_Integral): TypeIs_Integral;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m5">5</A>.
</BLOCKQUOTE>


<A NAME="s6.3.12"><H3>6.3.12  Bitwise inclusive OR operator</H3></A>

<BLOCKQUOTE>
<A NAME="m104"><I>Bitwise inclusive OR operator</I>[104]</A>==<BLOCKQUOTE><PRE>
inclusive_OR_expression:
  exclusive_OR_expression /
  inclusive_OR_expression '|' exclusive_OR_expression.
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m105"><I>Bitwise inclusive OR operator semantics</I>[105]</A>==<BLOCKQUOTE><PRE>
INDICATION Bitwise_Or_Indication: Bitwise_Or_Op;
OPER Bitwise_Or_Op(TypeIs_Integral, TypeIs_Integral): TypeIs_Integral;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m5">5</A>.
</BLOCKQUOTE>


<A NAME="s6.3.13"><H3>6.3.13  Logical AND operator</H3></A>

<BLOCKQUOTE>
<A NAME="m106"><I>Logical AND operator</I>[106]</A>==<BLOCKQUOTE><PRE>
logical_AND_expression:
  inclusive_OR_expression /
  logical_AND_expression '&amp;&amp;' inclusive_OR_expression.
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m107"><I>Logical AND operator semantics</I>[107]</A>==<BLOCKQUOTE><PRE>
INDICATION And_Indication: And_Op, Ptr_And_Op;
OPER And_Op(TypeIs_Scalar, TypeIs_Scalar): TypeIs_int;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m5">5</A>.
</BLOCKQUOTE>


Distinct logical AND operators are defined for each pointer
type other than <TT>TypeIs_VoidPointer</TT>.
<BLOCKQUOTE>
<A NAME="m108"><I>Operators defined for this pointer type</I>[108]</A>==<BLOCKQUOTE><PRE>
OPER Ptr_And_Op(TypeIs_Pointer, TypeIs_Pointer): TypeIs_int;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m74">74</A>, <A HREF="#m78">78</A>, <A HREF="#m81">81</A>, <A HREF="#m83">83</A>, <A HREF="#m86">86</A>, <A HREF="#m91">91</A>, <A HREF="#m96">96</A>, <A HREF="#m99">99</A>, <A HREF="#m108">108</A>, <A HREF="#m111">111</A>, <A HREF="#m114">114</A>, <A HREF="#m119">119</A>, and <A HREF="#m124">124</A>.<BR>
This macro is invoked in definition <A HREF="#m39">39</A>.
</BLOCKQUOTE>


<A NAME="s6.3.14"><H3>6.3.14  Logical OR operator</H3></A>

<BLOCKQUOTE>
<A NAME="m109"><I>Logical OR operator</I>[109]</A>==<BLOCKQUOTE><PRE>
logical_OR_expression:
  logical_AND_expression /
  logical_OR_expression '||' logical_AND_expression.
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m110"><I>Logical OR operator semantics</I>[110]</A>==<BLOCKQUOTE><PRE>
INDICATION Or_Indication: Or_Op, Ptr_Or_Op;  
OPER Or_Op(TypeIs_Scalar, TypeIs_Scalar): TypeIs_int;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m5">5</A>.
</BLOCKQUOTE>


Distinct logical OR operators are defined for each pointer
type other than <TT>TypeIs_VoidPointer</TT>.
<BLOCKQUOTE>
<A NAME="m111"><I>Operators defined for this pointer type</I>[111]</A>==<BLOCKQUOTE><PRE>
OPER Ptr_Or_Op(TypeIs_Pointer, TypeIs_Pointer): TypeIs_int;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m74">74</A>, <A HREF="#m78">78</A>, <A HREF="#m81">81</A>, <A HREF="#m83">83</A>, <A HREF="#m86">86</A>, <A HREF="#m91">91</A>, <A HREF="#m96">96</A>, <A HREF="#m99">99</A>, <A HREF="#m108">108</A>, <A HREF="#m111">111</A>, <A HREF="#m114">114</A>, <A HREF="#m119">119</A>, and <A HREF="#m124">124</A>.<BR>
This macro is invoked in definition <A HREF="#m39">39</A>.
</BLOCKQUOTE>


<A NAME="s6.3.15"><H3>6.3.15  Conditional operator</H3></A>

<BLOCKQUOTE>
<A NAME="m112"><I>Conditional operator</I>[112]</A>==<BLOCKQUOTE><PRE>
conditional_expression:
  logical_OR_expression /
  logical_OR_expression '?' expression ':' conditional_expression .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m113"><I>Conditional operator semantics</I>[113]</A>==<BLOCKQUOTE><PRE>
INDICATION Conditional_Indication: Conditional_Op, Ptr_Conditional_Op;
OPER Conditional_Op(TypeIs_Scalar): TypeIs_int;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m5">5</A>.
</BLOCKQUOTE>


Distinct conditional operators are defined for each pointer
type other than <TT>TypeIs_VoidPointer</TT>.
<BLOCKQUOTE>
<A NAME="m114"><I>Operators defined for this pointer type</I>[114]</A>==<BLOCKQUOTE><PRE>
OPER Ptr_Conditional_Op(TypeIs_Pointer): TypeIs_int;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m74">74</A>, <A HREF="#m78">78</A>, <A HREF="#m81">81</A>, <A HREF="#m83">83</A>, <A HREF="#m86">86</A>, <A HREF="#m91">91</A>, <A HREF="#m96">96</A>, <A HREF="#m99">99</A>, <A HREF="#m108">108</A>, <A HREF="#m111">111</A>, <A HREF="#m114">114</A>, <A HREF="#m119">119</A>, and <A HREF="#m124">124</A>.<BR>
This macro is invoked in definition <A HREF="#m39">39</A>.
</BLOCKQUOTE>


This specification constrains only the first operand of the conditional.
Temporarily, the specification will simply balance the second and third
operands of the conditional to obtain the result type.
<A NAME="s6.3.16"><H3>6.3.16  Assignment operators</H3></A>

<BLOCKQUOTE>
<A NAME="m115"><I>Assignment operators</I>[115]</A>==<BLOCKQUOTE><PRE>
assignment_expression:
  conditional_expression /
  unary_expression assignment_operator assignment_expression .

assignment_operator:
  '=' / '*=' / '/=' / '%=' / '+=' / '-=' / '&lt;&lt;=' / '&gt;&gt;=' / '&amp;=' / '^=' / '|='.
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


An assignment operator is identified during semantic analysis in the same
way as any other dyadic operator.
It is therefore convenient to map the symbol <TT>assignment_operator</TT> to
<TT>binary_operator</TT> in the tree:
<BLOCKQUOTE>
<A NAME="m116"><I>Map the assignment operator symbol</I>[116]</A>==<BLOCKQUOTE><PRE>
binary_operator ::= assignment_operator .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m3">3</A>.
</BLOCKQUOTE>


<A NAME="s6.3.16.1"><H4>6.3.16.1  Simple assignment</H4></A>

<BLOCKQUOTE>
<A NAME="m117"><I>Simple assignment</I>[117]</A>==<BLOCKQUOTE><PRE>
INDICATION Assign_Indication: Assign_Op, Ptr_Assign_Op, Enum_Assign_Op,
Struct_Assign_Op, Union_Assign_Op, Ptr_Void_Assign_Op, Array_Assign_Op;

SET TypeIs_RHS_Arithmetic = TypeIs_Arithmetic;
OPER Assign_Op(TypeIs_Arithmetic, TypeIs_RHS_Arithmetic): TypeIs_Arithmetic;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m5">5</A>.
</BLOCKQUOTE>


By defining <TT>TypeIs_RHS_Scalar</TT> as being equal to
<TT>TypeIs_Scalar</TT> and then using these two set identifiers
in defining <TT>Assign_Op</TT>, the
specification allows different types of operands for the left and right
operands.
The type of the result is that of the left operand.
<P>
Distinct simple assignments are defined for each array type.
<BLOCKQUOTE>
<A NAME="m118"><I>Operators defined for this array type</I>[118]</A>==<BLOCKQUOTE><PRE>
OPER Array_Assign_Op(TypeIs_Array, pointerType): TypeIs_Array;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m73">73</A> and <A HREF="#m118">118</A>.<BR>
This macro is invoked in definition <A HREF="#m35">35</A>.
</BLOCKQUOTE>


Distinct simple assignments are defined for each pointer
type other than <TT>TypeIs_VoidPointer</TT>.
<BLOCKQUOTE>
<A NAME="m119"><I>Operators defined for this pointer type</I>[119]</A>==<BLOCKQUOTE><PRE>
OPER Ptr_Assign_Op(TypeIs_Pointer, TypeIs_Pointer): TypeIs_Pointer;
OPER Ptr_Void_Assign_Op(TypeIs_Pointer, TypeIs_VoidPointer): TypeIs_Pointer;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m74">74</A>, <A HREF="#m78">78</A>, <A HREF="#m81">81</A>, <A HREF="#m83">83</A>, <A HREF="#m86">86</A>, <A HREF="#m91">91</A>, <A HREF="#m96">96</A>, <A HREF="#m99">99</A>, <A HREF="#m108">108</A>, <A HREF="#m111">111</A>, <A HREF="#m114">114</A>, <A HREF="#m119">119</A>, and <A HREF="#m124">124</A>.<BR>
This macro is invoked in definition <A HREF="#m39">39</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m120"><I>Operator defined for this struct type</I>[120]</A>==<BLOCKQUOTE><PRE>
OPER Struct_Assign_Op(TypeIs_Struct, TypeIs_Struct): TypeIs_Struct;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m36">36</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m121"><I>Operator defined for this union type</I>[121]</A>==<BLOCKQUOTE><PRE>
OPER Union_Assign_Op(TypeIs_Union, TypeIs_Union): TypeIs_Union;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m37">37</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m122"><I>Operator defined for this enumeration type</I>[122]</A>==<BLOCKQUOTE><PRE>
OPER Enum_Assign_Op(TypeIs_Enum, TypeIs_int): TypeIs_Enum;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m34">34</A>.
</BLOCKQUOTE>


<A NAME="s6.3.16.2"><H4>6.3.16.2  Compound assignment</H4></A>

<BLOCKQUOTE>
<A NAME="m123"><I>Compound assignment</I>[123]</A>==<BLOCKQUOTE><PRE>
INDICATION Mult_Eq_Indication: Mult_Eq_Op;
INDICATION Div_Eq_Indication: Div_Eq_Op;
INDICATION Mod_Eq_Indication: Mod_Eq_Op;
INDICATION Plus_Eq_Indication: Plus_Eq_Op, Ptr_Plus_Eq_Op;  
INDICATION Minus_Eq_Indication: Minus_Eq_Op, Ptr_Minus_Eq_Op;  
INDICATION Bitwise_Shift_Left_Eq_Indication: Bitwise_Shift_Left_Eq_Op;
INDICATION Bitwise_Shift_Right_Eq_Indication: Bitwise_Shift_Right_Eq_Op;
INDICATION Bitwise_And_Eq_Indication: Bitwise_And_Eq_Op;
INDICATION Bitwise_XOr_Eq_Indication: Bitwise_XOr_Eq_Op;
INDICATION Bitwise_Or_Eq_Indication: Bitwise_Or_Eq_Op;

SET TypeIs_RHS_Integral = TypeIs_Integral;
OPER Mult_Eq_Op, Div_Eq_Op, Plus_Eq_Op, Minus_Eq_Op
        ( TypeIs_Arithmetic, TypeIs_RHS_Arithmetic ) : TypeIs_Arithmetic;
OPER Mod_Eq_Op, Bitwise_Shift_Left_Eq_Op, Bitwise_Shift_Right_Eq_Op,
        Bitwise_And_Eq_Op, Bitwise_XOr_Eq_Op, Bitwise_Or_Eq_Op
        ( TypeIs_Integral, TypeIs_RHS_Integral ) : TypeIs_Integral;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m5">5</A>.
</BLOCKQUOTE>


Distinct compound assignments are defined for each pointer
type other than <TT>TypeIs_VoidPointer</TT>.
The integral operand of a compound assignment involving a pointer and an
integer is specified to be a <TT>TypeIs_unsigned_long</TT>.
Any integral type can be converted to <TT>TypeIs_unsigned_long</TT> by means of
implicit conversions, so this specification is equivalent to that of the
standard.
The main reason for using <TT>TypeIs_unsigned_long</TT> is that OIL does not
permit sets as operand specifications within a class definition, but a
secondary reason is that this approach reduces the total number of
operators in the compiler's database.
<BLOCKQUOTE>
<A NAME="m124"><I>Operators defined for this pointer type</I>[124]</A>==<BLOCKQUOTE><PRE>
OPER Ptr_Plus_Eq_Op(TypeIs_Pointer, TypeIs_unsigned_long): TypeIs_Pointer;
OPER Ptr_Minus_Eq_Op(TypeIs_Pointer, TypeIs_unsigned_long): TypeIs_Pointer;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m74">74</A>, <A HREF="#m78">78</A>, <A HREF="#m81">81</A>, <A HREF="#m83">83</A>, <A HREF="#m86">86</A>, <A HREF="#m91">91</A>, <A HREF="#m96">96</A>, <A HREF="#m99">99</A>, <A HREF="#m108">108</A>, <A HREF="#m111">111</A>, <A HREF="#m114">114</A>, <A HREF="#m119">119</A>, and <A HREF="#m124">124</A>.<BR>
This macro is invoked in definition <A HREF="#m39">39</A>.
</BLOCKQUOTE>


<A NAME="s6.3.17"><H3>6.3.17  Comma operator</H3></A>

<BLOCKQUOTE>
<A NAME="m125"><I>Comma operator</I>[125]</A>==<BLOCKQUOTE><PRE>
expression:
  assignment_expression /
  expression ',' assignment_expression .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<A NAME="s6.4"><H2>6.4  Constant Expressions</H2></A>

<BLOCKQUOTE>
<A NAME="m126"><I>Constant Expressions</I>[126]</A>==<BLOCKQUOTE><PRE>
constant_expression:
  conditional_expression .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<A NAME="s6.5"><H2>6.5  Declarations</H2></A>

The parsing techniques used to resolve a syntactic ambiguity involving
<TT>typedef</TT> require a more complex definition for
<TT>declaration_specifiers</TT> than that given in the standard.
We give that definition in conjunction with our presentation of the parsing
method.
<BLOCKQUOTE>
<A NAME="m127"><I>Declarations</I>[127]</A>==<BLOCKQUOTE><PRE>
declaration:
  declaration_specifiers init_declarator_list_opt ';'
  <A HREF="#m216"><I>End of a declaration</I>[216]</A> .

<A HREF="#m136"><I>declaration_specifiers: </I>[136]</A>

init_declarator_list:
  init_declarator /
  init_declarator_list ',' init_declarator .

init_declarator:
  declarator /
  declarator '=' initializer .

<A HREF="#m132"><I>Storage-class specifiers</I>[132]</A>
<A HREF="#m134"><I>Type specifiers</I>[134]</A>
<A HREF="#m151"><I>Type qualifiers</I>[151]</A>
<A HREF="#m153"><I>Declarators</I>[153]</A>
<A HREF="#m165"><I>Type names</I>[165]</A>
<A HREF="#m169"><I>Initialization</I>[169]</A>
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


If an identifier has no linkage, there shall be no more than one
declaration of the identifier (in a declarator or type specifier) with the
same scope and the same name space, except for tags as specified in
6.5.2.3.
An instance of the Eli <TT>Unique</TT> module can be used
to detect multiply defined identifiers.
<BLOCKQUOTE>
<A NAME="m128"><I>Name analysis module for ordinary identifiers</I>[128]</A>==<BLOCKQUOTE><PRE>
$/Prop/Unique.gnrc :inst
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m10">10</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m129"><I>Semantics of declarations</I>[129]</A>==<BLOCKQUOTE><PRE>
SYMBOL file INHERITS RangeUnique END;

RULE: declaration_specifiers   LISTOF declaration_specifier END;
RULE: init_declarator_list     LISTOF init_declarator       END;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m129">129</A>, <A HREF="#m130">130</A>, and <A HREF="#m131">131</A>.<BR>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


A <TT>declaration</TT> specifies the interpretation and attributes of a set of
identifiers.
<P>
<TT>declaration_specifiers</TT> consists of a sequence of specifiers that
indicate the linkage, storage duration, and part of the type
of the entities that the declarators denote.
The type that they name is embodied in the <TT>TypeSpecified</TT> attribute of
the <TT>declaration_specifiers</TT> symbol.
Information gleaned from the declaration specifiers about the storage class
and type qualifier is embodied in six integer attributes that have the
value <TT>1</TT> if the corresponding specifier or qualifier was present and
<TT>0</TT> otherwise:
<BLOCKQUOTE>
<A NAME="m130"><I>Semantics of declarations</I>[130]</A>==<BLOCKQUOTE><PRE>
SYMBOL declaration_specifiers: TypeSpecified: DefTableKey;
ATTR   IsTypedef, IsExtern, IsStatic, IsRegister, IsConst, IsVolatile: int;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m129">129</A>, <A HREF="#m130">130</A>, and <A HREF="#m131">131</A>.<BR>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


The <TT>init_declarator_list_opt</TT> is a comma-separated sequence of
declarators, each of which may have additional type information, or an
initializer, or both.
The declarators contain the identifiers (if any) being declared.
<BLOCKQUOTE>
<A NAME="m131"><I>Semantics of declarations</I>[131]</A>==<BLOCKQUOTE><PRE>
SYMBOL declaration_specifiers: TypeSpecified: DefTableKey;
CHAIN                          TypeChain:     DefTableKey;

RULE: declaration ::= declaration_specifiers init_declarator_list_opt ';'
COMPUTE
  CHAINSTART init_declarator_list_opt.TypeChain=
      declaration_specifiers.TypeSpecified;
  init_declarator_list_opt.IsTypedef=declaration_specifiers.IsTypedef;
END;

SYMBOL init_declarator COMPUTE
  THIS.TypeChain=THIS.TypeChain DEPENDS_ON TAIL.TypeChain;
END;

RULE: init_declarator ::= declarator '=' initializer
COMPUTE
  IF(INCLUDING init_declarator_list_opt.IsTypedef,
     message(ERROR,&quot;Cannot assign values to types&quot;, 0, COORDREF));
END;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m129">129</A>, <A HREF="#m130">130</A>, and <A HREF="#m131">131</A>.<BR>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


The <TT>TypeSpecified</TT> attribute embodies the type information indicated by
the specifiers, and <TT>TypeChain</TT> carries that information to each declarator
in the list.
Additional type information provided by a declarator modifies the value of
<TT>TypeChain</TT>, so each <TT>init_declarator</TT> in the list must reset the value
for its successors.
<A NAME="s6.5.1"><H3>6.5.1  Storage-class specifiers</H3></A>

<BLOCKQUOTE>
<A NAME="m132"><I>Storage-class specifiers</I>[132]</A>==<BLOCKQUOTE><PRE>
storage_class_specifier:
  'typedef' <A HREF="#m217"><I>A typedef storage class specifier has been accepted</I>[217]</A> /
  'extern' /
  'static' /
  'auto' /
  'register' .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m127">127</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m133"><I>Declaration_specifier equivalence class</I>[133]</A>==<BLOCKQUOTE><PRE>
declaration_specifier ::= storage_class_specifier .
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m133">133</A>, <A HREF="#m135">135</A>, and <A HREF="#m152">152</A>.<BR>
This macro is invoked in definition <A HREF="#m3">3</A>.
</BLOCKQUOTE>


<A NAME="s6.5.2"><H3>6.5.2  Type specifiers</H3></A>

Each list of type specifiers must consist of the specifiers making up one
of the sets defined in the standard.
Five of the specifiers can only appear in lists of one element;
the other seven can be used to form lists of one or more elements.
It is important to distinguish the two kinds of type specifiers
syntactically in order to parse a sequence like ``<TT>int j;</TT>''
properly when <TT>j</TT> has been declared to be a <TT>typedef_name</TT>:
If the parser knows that a <TT>typedef_name</TT> cannot follow the
<TT>type_specifier</TT> <TT>int</TT>, then it will be forced to re-classify <TT>j</TT> as
an identifier.
If this information is not available to the parser, then it will detect a
syntax error after accepting <TT>j</TT> as a <TT>type_specifier</TT> and not finding
an identifier.
At that point, however, it is too late to re-classify <TT>j</TT>.
<P>
The <TT>type_specifier</TT>s that must appear singly are therefore
classified as <TT>type_specifier_1</TT>s, and those that may appear in groups as
<TT>type_specifier_2</TT>s.
<BLOCKQUOTE>
<A NAME="m134"><I>Type specifiers</I>[134]</A>==<BLOCKQUOTE><PRE>
type_specifier_1:
  'void' /
  'float' /
  struct_or_union_specifier /
  enum_specifier /
  typedef_name .

type_specifier_2:
  'char' /
  'short' /
  'int' /
  'long' /
  'double' /
  'signed' /
  'unsigned' .

<A HREF="#m138"><I>Structure and union specifiers</I>[138]</A>
<A HREF="#m142"><I>Enumeration specifiers</I>[142]</A>
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m127">127</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m135"><I>Declaration_specifier equivalence class</I>[135]</A>==<BLOCKQUOTE><PRE>
declaration_specifier ::= type_specifier_1 type_specifier_2 .
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m133">133</A>, <A HREF="#m135">135</A>, and <A HREF="#m152">152</A>.<BR>
This macro is invoked in definition <A HREF="#m3">3</A>.
</BLOCKQUOTE>


The phrase <TT>declaration_specifiers</TT> is then defined to enforce the
constraint syntactically.
All lists must be left-recursive here in order to detect the error at the
proper symbol:
<BLOCKQUOTE>
<A NAME="m136"><I>declaration_specifiers: </I>[136]</A>==<BLOCKQUOTE><PRE>
declaration_specifiers:
  ds0 / ds1 / ds2.

ds0:    /* List without type specifiers */
  storage_class_specifier / ds0 storage_class_specifier /
  type_qualifier / ds0 type_qualifier .

ds1:    /* List with a single type_specifier_1 */
  type_specifier_1 / ds0 type_specifier_1 /
  ds1 storage_class_specifier / ds1 type_qualifier .

ds2:    /* List with one or more type_specifier_2's */
  type_specifier_2 / ds0 type_specifier_2 /
  ds2 type_specifier_2 / ds2 storage_class_specifier / ds2 type_qualifier .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m127">127</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m137"><I>specifier_qualifier_list: </I>[137]</A>==<BLOCKQUOTE><PRE>
specifier_qualifier_list:
  sq0 / sq1 / sq2 .

sq0:    /* List without type specifiers */
  type_qualifier / sq0 type_qualifier .

sq1:    /* List with a single type_specifier_1 */
  type_specifier_1 / sq0 type_specifier_1 / sq1 type_qualifier .

sq2:    /* List with one or more type_specifier_2's */
  type_specifier_2 / sq0 type_specifier_2 /
  sq2 type_specifier_2 / sq2 type_qualifier .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m138">138</A>.
</BLOCKQUOTE>


<A NAME="s6.5.2.1"><H4>6.5.2.1  Structure and union specifiers</H4></A>

<BLOCKQUOTE>
<A NAME="m138"><I>Structure and union specifiers</I>[138]</A>==<BLOCKQUOTE><PRE>
struct_or_union_specifier:
  struct_or_union identifier component_list /
  struct_or_union component_list /
  struct_or_union identifier $';' .

<A HREF="#m29"><I>component_list: </I>[29]</A>

struct_or_union:
  'struct' /
  'union' .

struct_declaration_list:
  struct_declaration /
  struct_declaration_list struct_declaration.

struct_declaration:
  specifier_qualifier_list struct_declarator_list ';'.

<A HREF="#m137"><I>specifier_qualifier_list: </I>[137]</A>

struct_declarator_list:
  struct_declarator /
  struct_declarator_list ',' struct_declarator.

struct_declarator:
  member_declarator /
  member_declarator_opt ':' constant_expression .

<A HREF="#m160"><I>Member declarators</I>[160]</A>
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m134">134</A>.
</BLOCKQUOTE>


A <TT>member_declarator</TT> must be distinguished from a <TT>declarator</TT> during
parsing because the identifiers they declare belong to different name
spaces, and those name spaces are treated differently as the program is
parsed.
A <TT>member_declarator_opt</TT> is semantically equivalent to a
<TT>member_declarator</TT>:
<BLOCKQUOTE>
<A NAME="m139"><I>Member_declarator equivalence class</I>[139]</A>==<BLOCKQUOTE><PRE>
member_declarator ::= member_declarator_opt .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m3">3</A>.
</BLOCKQUOTE>


A <TT>component_list</TT> defines the name space in which the members are defined.
An instance of the Eli <TT>Unique</TT> module can be used
to detect multiply defined members.
<BLOCKQUOTE>
<A NAME="m140"><I>Name analysis modules for member identifiers</I>[140]</A>==<BLOCKQUOTE><PRE>
$/Prop/Unique.gnrc     +instance=Member +referto=Member :inst
$/Name/CScopeProp.gnrc +instance=Member +referto=Member :inst
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m10">10</A>.
</BLOCKQUOTE>


The single name space is associated with the <TT>file</TT> phrase, and a
separate environment is associated with each <TT>component_list</TT> phrase.
<BLOCKQUOTE>
<A NAME="m141"><I>Semantics of structure and union specifiers</I>[141]</A>==<BLOCKQUOTE><PRE>
SYMBOL file           INHERITS MemberRootScope,  MemberRangeUnique    END;
SYMBOL component_list INHERITS MemberRangeScope, MemberRangeScopeProp END;

RULE: struct_declaration ::= declaration_specifiers struct_declarator_list ';'
COMPUTE
  CHAINSTART struct_declarator_list.TypeChain=
    declaration_specifiers.TypeSpecified;
END;

SYMBOL struct_declarator_list COMPUTE
  THIS.TypeChain=THIS.TypeChain DEPENDS_ON TAIL.TypeChain;
END;
/*      NOREPORTS
SYMBOL struct_declarator COMPUTE
  THIS.TypeChain=THIS.TypeChain DEPENDS_ON TAIL.TypeChain;
END;
*/

SYMBOL MemberIdDef INHERITS MemberIdDefScope, MemberUnique COMPUTE
  IF(NOT(THIS.MemberUnique),
    message(ERROR, &quot;member identifier is multiply defined&quot;, 0, COORDREF));
END;

SYMBOL MemberIdUse:
  Sym:         int,
  MemberScope: Environment,
  MemberKey:   DefTableKey;

SYMBOL MemberIdUse COMPUTE
  SYNT.MemberKey=KeyInScope(THIS.MemberScope,THIS.Sym);
  IF(EQ(THIS.MemberScope,NoEnv),message(NOTE,&quot;No environment&quot;,0,COORDREF));
  IF(EQ(THIS.MemberKey, NoKey),
    message(ERROR, &quot;Not a member of this structure or union&quot;, 0, COORDREF));
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


A <TT>MemberIdUse</TT> appears only as the right operand of a selection operator.
The name space in which that member identifier was defined is the name
space associated with the structure or union that is the left operand of that
selection operator.
Thus it is not possible to obtain a definition table key value at
a <TT>MemberIdUse</TT> node until the analysis of expression types is complete.
<A NAME="s6.5.2.2"><H4>6.5.2.2  Enumeration specifiers</H4></A>

<BLOCKQUOTE>
<A NAME="m142"><I>Enumeration specifiers</I>[142]</A>==<BLOCKQUOTE><PRE>
enum_specifier:
  'enum' identifier <A HREF="#m218"><I>Begin a list of enumeration constants</I>[218]</A>
    '{' enumerator_list <A HREF="#m219"><I>End a list of enumeration constants</I>[219]</A> '}' /
  'enum' <A HREF="#m218"><I>Begin a list of enumeration constants</I>[218]</A>
    '{' enumerator_list <A HREF="#m219"><I>End a list of enumeration constants</I>[219]</A> '}' /
  'enum' identifier .

enumerator_list:
  <A HREF="#m25"><I>enumerator</I>[25]</A> /
  enumerator_list ',' <A HREF="#m25"><I>enumerator</I>[25]</A> .

enumerator:
  enumeration_constant /
  enumeration_constant '=' constant_expression.
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m134">134</A>.
</BLOCKQUOTE>


The identifiers in an enumerator list are declared as constants that have
type <TT>int</TT> and may appear wherever such are permitted.
Thus, the identifiers of enumeration constants declared in the same scope
shall all be distinct from each other and from other identifiers declared
in ordinary declarators.
<BLOCKQUOTE>
<A NAME="m143"><I>Semantics of enumeration specifiers</I>[143]</A>==<BLOCKQUOTE><PRE>
SYMBOL enumeration_constant INHERITS Unique COMPUTE
  ResetType(THIS.Key, TypeIs_int);
  IF(NOT(THIS.Unique),
    message(ERROR, &quot;identifier is multiply defined&quot;, 0, COORDREF));
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


<A NAME="s6.5.2.3"><H4>6.5.2.3  Tags</H4></A>

A type specifier of the following form declares the identifier to be the
tag of the structure, union or enumeration specified by the list:
<BLOCKQUOTE>
<A NAME="m144"><I>Tags</I>[144]</A>==<BLOCKQUOTE><PRE>
SYMBOL TagDef: HasCurly: int;

RULE: struct_or_union_specifier ::= struct_or_union TagDef component_list
COMPUTE
  TagDef.HasCurly=1;
  struct_or_union_specifier.Type=
    KeyForStructOrUnion(TagDef.TagKey,struct_or_union.IsStruct)
    DEPENDS_ON struct_or_union_specifier._C_GotTypes;
  component_list.MemberScopeKey=struct_or_union_specifier.Type;
  component_list._C_GotTypes=struct_or_union_specifier.Type;
END;

RULE: enum_specifier ::= 'enum' TagDef '{' enumerator_list '}'
COMPUTE
  TagDef.HasCurly=1;
  enum_specifier.Type=
    KeyForEnum(TagDef.TagKey) DEPENDS_ON enum_specifier.Specification;
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


If this declaration of the tag is visible, a subsequent declaration that
uses the tag and that omits the bracketed list specifies the declared
structure, union or enumerated type.
Subsequent declarations in the same scope shall omit the bracketed list.
<BLOCKQUOTE>
<A NAME="m145"><I>Check for multiply-declared tags</I>[145]</A>==<BLOCKQUOTE><PRE>
SYMBOL TagDef COMPUTE
  INH.HasCurly=0;
  THIS._C_TagGotKeys=
    IF(THIS.HasCurly,SetMultipleTag(THIS.TagKey,0,1))
    DEPENDS_ON THIS._C_TagGotKeys;
  IF(AND(THIS.HasCurly,GetMultipleTag(THIS.TagKey,0)),
    message(ERROR,&quot;Multiply-defined tag&quot;,0,COORDREF))
    DEPENDS_ON INCLUDING file.TagGotKeys;
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m146"><I>Property characterizing multiply-declared tags</I>[146]</A>==<BLOCKQUOTE><PRE>
MultipleTag: int;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m9">9</A>.
</BLOCKQUOTE>


If a type specifier of the following form occurs prior to the declaration
that defines the content, it declares a tag:
<BLOCKQUOTE>
<A NAME="m147"><I>Tag that may or may not be a declaration</I>[147]</A>==<BLOCKQUOTE><PRE>
RULE: struct_or_union_specifier ::= struct_or_union identifier
COMPUTE
  .VisibleKey=
    KeyInEnv(INCLUDING TagAnyScope.TagEnv,identifier)
    DEPENDS_ON struct_or_union_specifier._C_TagGotKeys;
  .FinalKey=
    IF(NE(.VisibleKey,NoKey),
      .VisibleKey,
      DefineIdn(INCLUDING TagAnyScope.TagEnv,identifier));
  struct_or_union_specifier._C_TagGotKeys=.FinalKey;
  struct_or_union_specifier.Type=
    KeyForStructOrUnion(.FinalKey,struct_or_union.IsStruct)
    DEPENDS_ON struct_or_union_specifier._C_GotTypes;
  struct_or_union_specifier._C_GotTypes=struct_or_union_specifier.Type;
END;

ATTR VisibleKey, FinalKey: DefTableKey;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


A similar construction with <TT>enum</TT> does not exist and is not necessary as
there can be no mutual dependencies between the declaration of an
enumerated type and any other type.
<BLOCKQUOTE>
<A NAME="m148"><I>Use of an enumerated type tag</I>[148]</A>==<BLOCKQUOTE><PRE>
RULE: enum_specifier ::= 'enum' TagUse
COMPUTE
  enum_specifier.Type=
    GetType(TagUse.TagKey, NoKey) DEPENDS_ON enum_specifier.Specification;
END;

SYMBOL TagUse COMPUTE
  IF(EQ(THIS.TagKey, NoKey),
    message(ERROR, &quot;Identifier is not defined&quot;, 0, COORDREF));
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


A declaration of the following form specifies a structure or union type and
declares a tag, both of which are visible only within the scope in which
the declaration occurs:
<BLOCKQUOTE>
<A NAME="m149"><I>Forward definition of a tag</I>[149]</A>==<BLOCKQUOTE><PRE>
RULE: declaration ::= struct_or_union TagDef ';'
COMPUTE
  declaration._C_GotTypes=
    KeyForStructOrUnion(TagDef.TagKey,struct_or_union.IsStruct)
    DEPENDS_ON declaration._C_GotTypes;
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


A type specifier of the following form specifies a new structure, union or
enumerated type, within the translation unit, that can only be referred to
by the declaration of which it is a part.
<BLOCKQUOTE>
<A NAME="m150"><I>Anonymous structure, union or enumerated type</I>[150]</A>==<BLOCKQUOTE><PRE>
RULE: struct_or_union_specifier ::= struct_or_union component_list
COMPUTE
  struct_or_union_specifier.Type=
    KeyForStructOrUnion(NoKey,struct_or_union.IsStruct)
    DEPENDS_ON struct_or_union_specifier._C_GotTypes;
  component_list.MemberScopeKey=struct_or_union_specifier.Type;
  component_list._C_GotTypes=struct_or_union_specifier.Type;
END;

RULE: enum_specifier ::= 'enum' '{' enumerator_list '}'
COMPUTE
  enum_specifier.Type=
    KeyForEnum(NoKey) DEPENDS_ON enum_specifier.Specification;
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


<A NAME="s6.5.3"><H3>6.5.3  Type qualifiers</H3></A>

<BLOCKQUOTE>
<A NAME="m151"><I>Type qualifiers</I>[151]</A>==<BLOCKQUOTE><PRE>
type_qualifier:
  'const' /
  'volatile'.
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m127">127</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m152"><I>Declaration_specifier equivalence class</I>[152]</A>==<BLOCKQUOTE><PRE>
declaration_specifier ::= type_qualifier .
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m133">133</A>, <A HREF="#m135">135</A>, and <A HREF="#m152">152</A>.<BR>
This macro is invoked in definition <A HREF="#m3">3</A>.
</BLOCKQUOTE>


<A NAME="s6.5.4"><H3>6.5.4  Declarators</H3></A>

<BLOCKQUOTE>
<A NAME="m153"><I>Declarators</I>[153]</A>==<BLOCKQUOTE><PRE>
declarator:
  pointer <A HREF="#m26"><I>Innermost declarator</I>[26]</A> <A HREF="#m197"><I>Pointer declarator</I>[197]</A> /
  <A HREF="#m26"><I>Innermost declarator</I>[26]</A> /
  pointer shielded <A HREF="#m197"><I>Pointer declarator</I>[197]</A> /
  shielded .
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m153">153</A>, <A HREF="#m155">155</A>, <A HREF="#m156">156</A>, and <A HREF="#m158">158</A>.<BR>
This macro is invoked in definition <A HREF="#m127">127</A>.
</BLOCKQUOTE>


The standard uses an optional <TT>pointer</TT>.
This option must be made explicit here in order to avoid an LALR(1)
conflict.
<P>
An ordinary identifier must be bound at the end of its declarator.
If a declarator has another declarator as a component, then the identifier
will be bound at the end of the component declarator and no binding should
take place at the end of the outer declarator.
A new nonterminal, <TT>shielded</TT>, is used to distinguish these cases so that
the the parser can take the proper action.
This distinction is only relevant during parsing; semantically,
<TT>shielded</TT> is completely equivalent to <TT>direct_declarator</TT>:
<BLOCKQUOTE>
<A NAME="m154"><I>Direct_declarator equivalence class</I>[154]</A>==<BLOCKQUOTE><PRE>
direct_declarator ::= shielded .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m3">3</A>.
</BLOCKQUOTE>


<TT>OrdinaryIdDef</TT> is a defining occurrence of an ordinary identifier.
The kind of identifier being defined depends upon the context in which the
<TT>declarator</TT> appears.
<BLOCKQUOTE>
<A NAME="m155"><I>Declarators</I>[155]</A>==<BLOCKQUOTE><PRE>
direct_declarator:
  OrdinaryIdDef <A HREF="#m222"><I>Defer binding the declared identifier</I>[222]</A> /
  direct_declarator <A HREF="#m196"><I>Array declarator</I>[196]</A> '[' constant_exp_opt ']' /
  direct_declarator parameter_part .

shielded:
  '(' declarator ')' /
  shielded <A HREF="#m196"><I>Array declarator</I>[196]</A> '[' constant_exp_opt ']' /
  shielded parameter_part .
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m153">153</A>, <A HREF="#m155">155</A>, <A HREF="#m156">156</A>, and <A HREF="#m158">158</A>.<BR>
This macro is invoked in definition <A HREF="#m127">127</A>.
</BLOCKQUOTE>


The symbol <TT>parameter_part</TT> represents a significant semantic concept,
the function prototype scope for tags.
This phrase is not distinguished in the standard, making the corresponding
semantics difficult to express.
<BLOCKQUOTE>
<A NAME="m156"><I>Declarators</I>[156]</A>==<BLOCKQUOTE><PRE>
parameter_part:
  <A HREF="#m186"><I>Prototype begin</I>[186]</A> '(' <A HREF="#m198"><I>Begin a parameter list</I>[198]</A> parameters
    <A HREF="#m187"><I>Prototype end</I>[187]</A> ')' .

parameters:
  <A HREF="#m194"><I>Begin a parameter_type_list</I>[194]</A> parameter_type_list
    <A HREF="#m195"><I>End a parameter_type_list</I>[195]</A> /
  identifier_list_opt .
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m153">153</A>, <A HREF="#m155">155</A>, <A HREF="#m156">156</A>, and <A HREF="#m158">158</A>.<BR>
This macro is invoked in definition <A HREF="#m127">127</A>.
</BLOCKQUOTE>


The symbol <TT>parameters</TT> is introduced to simplify attachment of parsing
actions, but it is semantically equivalent to a <TT>parameter_part</TT>:
<BLOCKQUOTE>
<A NAME="m157"><I>Parameter_part equivalence class</I>[157]</A>==<BLOCKQUOTE><PRE>
  parameter_part ::= parameters .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m3">3</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m158"><I>Declarators</I>[158]</A>==<BLOCKQUOTE><PRE>
pointer:
  '*' type_qualifier_list_opt /
  '*' type_qualifier_list_opt pointer .

type_qualifier_list_opt: type_qualifier* .

parameter_type_list:
  parameter_list /
  parameter_list ',' '...' .

parameter_list:
  parameter_declaration /
  parameter_list ',' parameter_declaration.

parameter_declaration:
  declaration_specifiers declarator /
  declaration_specifiers abstract_declarator_opt .

identifier_list:
  OrdinaryIdDef <A HREF="#m224"><I>Bind the identifier immediately</I>[224]</A> /
  identifier_list ',' OrdinaryIdDef <A HREF="#m224"><I>Bind the identifier immediately</I>[224]</A> .
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m153">153</A>, <A HREF="#m155">155</A>, <A HREF="#m156">156</A>, and <A HREF="#m158">158</A>.<BR>
This macro is invoked in definition <A HREF="#m127">127</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m159"><I>Semantics of declarators</I>[159]</A>==<BLOCKQUOTE><PRE>
RULE: direct_declarator ::= IdDef
COMPUTE
  direct_declarator._C_GotTypes=
    ORDER(
      ResetType(IdDef.Key, direct_declarator.TypeChain),
      IF(NE(GetSynCode(IdDef.Key,UnboundIdUse),typedef_name),
        <A HREF="#m162"><I>Can be the operand of &amp;</I>[162]</A> (`direct_declarator.TypeChain')),
      direct_declarator._C_GotTypes);
END;

RULE: member_direct_declarator ::= MemberIdDef
COMPUTE
  member_direct_declarator._C_GotTypes=
    ORDER(
      <A HREF="#m162"><I>Can be the operand of &amp;</I>[162]</A> (`member_direct_declarator.TypeChain'),
      ResetType(MemberIdDef.MemberKey,member_direct_declarator.TypeChain),
      member_direct_declarator._C_GotTypes);
END;

SYMBOL parameter_id COMPUTE
  THIS.TypeChain=ORDER(ResetType(THIS.Key, TypeIs_int),THIS.TypeChain);
END;

RULE: parameter_declaration ::= declaration_specifiers declarator
COMPUTE
  CHAINSTART declarator.TypeChain=
    declaration_specifiers.TypeSpecified;
END;

RULE: parameter_declaration ::= declaration_specifiers abstract_declarator
COMPUTE
  CHAINSTART abstract_declarator.TypeChain=
    declaration_specifiers.TypeSpecified;
  parameter_declaration._C_GotTypes=abstract_declarator.TypeChain;
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


There is little difference between the phrase structure of a
<TT>member_declarator</TT> and that of a <TT>declarator</TT>.
The former is defined to preserve the context in which a declarator
occurs, so that different actions can be attached in the two cases.
A <TT>declarator</TT> declares an ordinary identifier, which must be consistently
renamed during parsing, while a <TT>member_declarator</TT> declares a member
identifier, which requires no action during parsing.
<BLOCKQUOTE>
<A NAME="m160"><I>Member declarators</I>[160]</A>==<BLOCKQUOTE><PRE>
member_declarator:
  pointer member_direct_declarator / member_direct_declarator .

member_direct_declarator:
  identifier /
  '(' member_declarator ')' /
  member_direct_declarator '[' constant_exp_opt ']' /
  member_direct_declarator parameter_part .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m138">138</A>.
</BLOCKQUOTE>


Section 6.5.4.3 of the standard requires that an identifier list in a
function declarator that is not part of a function definition be empty.
Since a <TT>member_declarator</TT> cannot be a part of a function definition,
there is no need for a non-empty identifier list alternative.
<A NAME="s6.5.4.1"><H4>6.5.4.1  Pointer declarators</H4></A>

<BLOCKQUOTE>
<A NAME="m161"><I>Pointer declarators</I>[161]</A>==<BLOCKQUOTE><PRE>
RULE: pointer ::= '*' declaration_specifiers
COMPUTE
  pointer.TypeChain=
    KeyForQualifier(
      KeyForPointer(pointer.TypeChain),
      declaration_specifiers.IsConst,
      declaration_specifiers.IsVolatile);
END;

RULE: pointer ::=  '*' declaration_specifiers pointer
COMPUTE
  pointer[2].TypeChain=
    KeyForQualifier(
      KeyForPointer(pointer[1].TypeChain),
      declaration_specifiers.IsConst,
      declaration_specifiers.IsVolatile);
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


The concrete syntax restricts the <TT>declaration_specifiers</TT> to be either
empty or consist solely of type qualifiers.
<TT>KeyForQualifier</TT> accounts for any qualifiers that might be present.
<P>
Pointer types also have to be guaranteed whenever an object that could be the
operand of <TT>&amp;</TT> is declared.
The reason is that ``referencing'' operators are defined for each pointer
type, so the type must be instantiated before <TT>&amp;</TT> can be identified.
<BLOCKQUOTE>
<A NAME="m162"><I>Can be the operand of &amp;</I>[162]</A>(&#182;1)==<BLOCKQUOTE><PRE>KeyForPointer(&#182;1)</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m159">159</A>.
</BLOCKQUOTE>


<A NAME="s6.5.4.2"><H4>6.5.4.2  Array declarators</H4></A>

<BLOCKQUOTE>
<A NAME="m163"><I>Array declarators</I>[163]</A>==<BLOCKQUOTE><PRE>
RULE: direct_declarator ::= direct_declarator '[' constant_exp_opt ']'
COMPUTE
  direct_declarator[2].TypeChain=KeyForArray(direct_declarator[1].TypeChain);
END;

RULE: member_direct_declarator ::= 
  member_direct_declarator '[' constant_exp_opt ']'
COMPUTE
  member_direct_declarator[2].TypeChain=
    KeyForArray(member_direct_declarator[1].TypeChain);
END;

RULE: direct_abs_declarator ::= '[' constant_exp_opt ']'
COMPUTE
  direct_abs_declarator.TypeChain=KeyForArray(direct_abs_declarator.TypeChain);
END;

RULE: direct_abs_declarator ::= direct_abs_declarator '[' constant_exp_opt ']'
COMPUTE
  direct_abs_declarator[2].TypeChain=
    KeyForArray(direct_abs_declarator[1].TypeChain);
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


<A NAME="s6.5.4.3"><H4>6.5.4.3  Function declarators (including prototypes)</H4></A>

<BLOCKQUOTE>
<A NAME="m164"><I>Function declarators (including prototypes)</I>[164]</A>==<BLOCKQUOTE><PRE>
RULE: direct_declarator ::= direct_declarator parameter_part
COMPUTE
  direct_declarator[2].TypeChain=
    KeyForFunction(direct_declarator[1].TypeChain);
END;

RULE: member_direct_declarator ::= member_direct_declarator parameter_part
COMPUTE
  member_direct_declarator[2].TypeChain=
    KeyForFunction(member_direct_declarator[1].TypeChain);
END;

RULE: direct_abs_declarator ::= '(' parameter_type_list_opt ')'
COMPUTE
  direct_abs_declarator.TypeChain=
    KeyForFunction(direct_abs_declarator.TypeChain);
END;

RULE: direct_abs_declarator ::= 
     direct_abs_declarator '(' parameter_type_list_opt ')'
COMPUTE
  direct_abs_declarator[2].TypeChain=
    KeyForFunction(direct_abs_declarator[1].TypeChain);
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


<A NAME="s6.5.5"><H3>6.5.5  Type names</H3></A>

The standard uses an optional <TT>pointer</TT> and
an optional <TT>direct_abs_declarator</TT>.
These options must be made explicit here in order to avoid an LALR(1)
conflict.
<BLOCKQUOTE>
<A NAME="m165"><I>Type names</I>[165]</A>==<BLOCKQUOTE><PRE>
type_name:
  specifier_qualifier_list abstract_declarator_opt .

abstract_declarator:
  pointer /
  pointer direct_abs_declarator / direct_abs_declarator .

direct_abs_declarator:
  '(' abstract_declarator ')' /
  direct_abs_declarator '[' constant_exp_opt ']' /
  direct_abs_declarator '(' parameter_type_list_opt ')' /
  '[' constant_exp_opt ']' /
  '(' parameter_type_list_opt ')' .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m127">127</A>.
</BLOCKQUOTE>


An <TT>abstract_declarator_opt</TT> is sematically equivalent to an
<TT>abstract_declarator</TT>:
<BLOCKQUOTE>
<A NAME="m166"><I>Abstract_declarator equivalence class</I>[166]</A>==<BLOCKQUOTE><PRE>
abstract_declarator ::= abstract_declarator_opt .
declaration_specifiers ::= type_qualifier_list_opt specifier_qualifier_list .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m3">3</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m167"><I>Semantics of type names</I>[167]</A>==<BLOCKQUOTE><PRE>
RULE: type_name ::= declaration_specifiers abstract_declarator
COMPUTE
  CHAINSTART abstract_declarator.TypeChain=
    declaration_specifiers.TypeSpecified;
  type_name.Type=abstract_declarator.TypeChain;
  type_name._C_GotTypes=type_name.Type;
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


<A NAME="s6.5.6"><H3>6.5.6  Type definitions</H3></A>

In order to avoid syntactic ambiguity, a <TT>typedef_name</TT> must be
recognized by the lexical analyzer.
<BLOCKQUOTE>
<A NAME="m168"><I>Type definitions</I>[168]</A>==<BLOCKQUOTE><PRE>
typedef_name:  $[_a-zA-Z][_a-zA-Z0-9]*
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m16">16</A>.
</BLOCKQUOTE>


Note that there is no lexical distinction between a <TT>typedef_name</TT> and an
<TT>identifier</TT>.
Thus semantic information must be used to differentiate them,
and the differentiation must occur during parsing.
<A NAME="s6.5.7"><H3>6.5.7  Initialization</H3></A>

<BLOCKQUOTE>
<A NAME="m169"><I>Initialization</I>[169]</A>==<BLOCKQUOTE><PRE>
initializer:
  assignment_expression /
  '{' initializer_list '}' /
  '{' initializer_list ',' '}'.

initializer_list:
  initializer /
  initializer_list ',' initializer.
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m127">127</A>.
</BLOCKQUOTE>


<A NAME="s6.6"><H2>6.6  Statements</H2></A>

<BLOCKQUOTE>
<A NAME="m170"><I>Statements</I>[170]</A>==<BLOCKQUOTE><PRE>
statement:
  labeled_statement /
  <A HREF="#m189"><I>Begin a nested compound statement</I>[189]</A> compound_statement /
  expression_statement /
  selection_statement /
  iteration_statement /
  jump_statement.

<A HREF="#m171"><I>Labeled statements</I>[171]</A>
<A HREF="#m172"><I>Compound statements</I>[172]</A>
<A HREF="#m173"><I>Expression statements</I>[173]</A>
<A HREF="#m174"><I>Selection statements</I>[174]</A>
<A HREF="#m175"><I>Iteration statements</I>[175]</A>
<A HREF="#m176"><I>Jump statements</I>[176]</A>
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<A NAME="s6.6.1"><H3>6.6.1  Labeled statements</H3></A>

The left context of the <TT>identifier</TT> in a <TT>labeled_statement</TT> is
identical to that of an expression.
Therefore the parser cannot provide any information that would allow the
lexical analyzer to distinguish the label from an ordinary identifier.
<P>
In the absence of parser information, the lexical analyzer will classify an
identifier as an ordinary identifier (one of <TT>UnboundIdUse</TT>,
<TT>OrdinaryIdUse</TT> or <TT>typedef_name</TT> depending on the context).
Thus the parser must accept any of these classifications as a valid label.
<BLOCKQUOTE>
<A NAME="m171"><I>Labeled statements</I>[171]</A>==<BLOCKQUOTE><PRE>
labeled_statement:
  UnboundIdUse ':' statement /
  OrdinaryIdUse ':' statement /
  typedef_name ':' statement /
  'case' constant_expression ':' statement /
  'default' ':' statement.
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m170">170</A>.
</BLOCKQUOTE>


<A NAME="s6.6.2"><H3>6.6.2  Compound statements</H3></A>

<BLOCKQUOTE>
<A NAME="m172"><I>Compound statements</I>[172]</A>==<BLOCKQUOTE><PRE>
compound_statement:
  '{' declaration_list statement_list_opt <A HREF="#m188"><I>End a compound statement</I>[188]</A> '}' /
  '{' statement_list_opt <A HREF="#m188"><I>End a compound statement</I>[188]</A> '}' .

declaration_list:
  declaration /
  declaration_list declaration .

statement_list:
  statement /
  statement_list statement .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m170">170</A>.
</BLOCKQUOTE>


<A NAME="s6.6.3"><H3>6.6.3  Expression and null statements</H3></A>

<BLOCKQUOTE>
<A NAME="m173"><I>Expression statements</I>[173]</A>==<BLOCKQUOTE><PRE>
expression_statement: expression_opt ';' .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m170">170</A>.
</BLOCKQUOTE>


<A NAME="s6.6.4"><H3>6.6.4  Selection statements</H3></A>

There is an LALR(1) conflict here between the first and second alternatives.
This conflict is resolved by the modification <TT>$'else'</TT>, which prevents
reduction of the first alternative if the lookahead symbol is <TT>else</TT>.
<BLOCKQUOTE>
<A NAME="m174"><I>Selection statements</I>[174]</A>==<BLOCKQUOTE><PRE>
selection_statement:
  'if' '(' expression ')' statement $'else' /
  'if' '(' expression ')' statement 'else' statement /
  'switch' '(' expression ')' statement.
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m170">170</A>.
</BLOCKQUOTE>


<A NAME="s6.6.5"><H3>6.6.5  Iteration statements</H3></A>

The nointerminals <TT>for_init</TT>, <TT>for_test</TT> and <TT>for_incr</TT> are all
optional expressions.
They are used to preserve context without a combinatorial explosion.
<BLOCKQUOTE>
<A NAME="m175"><I>Iteration statements</I>[175]</A>==<BLOCKQUOTE><PRE>
iteration_statement:
  'while' '(' expression ')' statement /
  'do' statement 'while' '(' expression ')' ';' /
  'for' '(' for_init ';' for_test ';' for_incr ')' statement.
for_init: / expression .
for_test: / expression .
for_incr: / expression .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m170">170</A>.
</BLOCKQUOTE>


<A NAME="s6.6.6"><H3>6.6.6  Jump statements</H3></A>

<BLOCKQUOTE>
<A NAME="m176"><I>Jump statements</I>[176]</A>==<BLOCKQUOTE><PRE>
jump_statement:
  'goto' identifier ';' /
  'continue' ';' /
  'break' ';' /
  'return' expression_opt ';' .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m170">170</A>.
</BLOCKQUOTE>


<A NAME="s6.7"><H2>6.7  External definitions</H2></A>

<BLOCKQUOTE>
<A NAME="m177"><I>External definitions</I>[177]</A>==<BLOCKQUOTE><PRE>
translation_unit:
  external_declaration /
  translation_unit external_declaration .

external_declaration:
  BeginExtDecl function_definition /
  BeginExtDecl declaration .

BeginExtDecl: <A HREF="#m191"><I>Begin an external declaration</I>[191]</A> .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<A NAME="s6.7.1"><H3>6.7.1  Function definitions</H3></A>

The standard uses an optional <TT>declaration_specifiers</TT>.
This option must be made explicit here in order to avoid an LALR(1)
conflict.
<BLOCKQUOTE>
<A NAME="m178"><I>Function definitions</I>[178]</A>==<BLOCKQUOTE><PRE>
function_definition:
  declaration_specifiers declarator <A HREF="#m190"><I>Function definition</I>[190]</A>
    declaration_list_opt compound_statement /
  declarator <A HREF="#m190"><I>Function definition</I>[190]</A>
    declaration_list_opt compound_statement .
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m2">2</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m179"><I>Semantics of function definitions</I>[179]</A>==<BLOCKQUOTE><PRE>
RULE: function_definition ::=
     declaration_specifiers declarator declaration_list_opt compound_statement
COMPUTE
  CHAINSTART declarator.TypeChain=declaration_specifiers.TypeSpecified;
END;

RULE: function_definition ::=
                            declarator declaration_list_opt compound_statement
COMPUTE
  CHAINSTART declarator.TypeChain=TypeIs_int;
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


<A NAME="s6.7.2"><H3>6.7.2  External object definitions</H3></A>

<A NAME="s7"><H1>7  Library</H1></A>

<A NAME="s8"><H1>8  Consistent Renaming for Ordinary Identifiers</H1></A>

An ordinary identifier may be accepted by the parser as any of the
terminals <TT>OrdinaryIdDef</TT>, <TT>OrdinaryIdUse</TT>, <TT>typedef_name</TT>,
<TT>UnboundIdUse</TT> or <TT>identifier</TT>.
Defining occurrences are represented in the tree by either an <TT>IdDef</TT>
node or a <TT>parameter_id</TT> node, applied occurrences by an <TT>IdUse</TT> node.
<P>
If the parser has accepted an <TT>OrdinaryIdUse</TT> or a <TT>typedef_name</TT>
in the context of a <TT>LabelDef</TT>, then that identifier must be renamed in
the label name space.
The original identifier was stored as the <TT>Symbol</TT> property of the
ordinary identifier, so it can be recovered easily:
<BLOCKQUOTE>
<A NAME="m180"><I>Semantics of identifiers</I>[180]</A>==<BLOCKQUOTE><PRE>
RULE: LabelDef ::= OrdinaryIdUse
COMPUTE
   LabelDef.Sym = GetSymbol(OrdinaryIdStackArray(OrdinaryIdUse), 0);
END;

RULE: LabelDef ::= typedef_name
COMPUTE
   LabelDef.Sym = GetSymbol(OrdinaryIdStackArray(typedef_name), 0);
END;

RULE: LabelDef ::= UnboundIdUse
COMPUTE
   LabelDef.Sym = UnboundIdUse;
END;

RULE: LabelUse ::= identifier
COMPUTE
   LabelUse.Sym = identifier;
END;

RULE: TagDef ::= identifier
COMPUTE
  TagDef.Sym=identifier;
END;

RULE: TagUse ::= identifier
COMPUTE
  TagUse.Sym=identifier;
END;

RULE: MemberIdDef ::= identifier
COMPUTE
  MemberIdDef.Sym = identifier;
END;

RULE: MemberIdUse ::= identifier
COMPUTE
  MemberIdUse.Sym = identifier;
END;

RULE: enumeration_constant ::= OrdinaryIdDef
COMPUTE
  enumeration_constant.Key=OrdinaryIdStackArray(OrdinaryIdDef);
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


Scope rules are embodied in the concept of an <EM>environment</EM>, which is a
set of bindings for identifiers.
Environments can be nested, in which case the binding in the innermost
environment hides those in outer environments.
Eli provides a module that exports an <TT>Environment</TT> data type with
operations to establish bindings, find bindings and create nested sets of
bindings.
This module is used to support the consistent renaming process.
<BLOCKQUOTE>
<A NAME="m181"><I>Ordinary identifier name space</I>[181]</A>==<BLOCKQUOTE><PRE>
$/Name/envmod.specs
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m27">27</A>.
</BLOCKQUOTE>


The environment module provides two operations for creating environments:
<TT>NewEnv</TT> and <TT>NewScope</TT>.
<TT>NewEnv</TT> should be used once to create the <TT>Environment</TT> value for the
outermost scope of a name space, and <TT>NewScope</TT> should be used to create
<TT>Environment</TT> values for nested scopes.
An <TT>Environment</TT> value represents a set of bindings, and may be related
to another <TT>Environment</TT> value.
<P>
The operations that create bindings (<TT>DefineIdn</TT> and <TT>AddIdn</TT>)
take an <TT>Environment</TT> value as a parameter.
If no element of the set is a binding for the given identifier, they add a
binding to the set; otherwise the set is left unchanged.
In either case, the set will contain a binding for the given identifier
after the operation is completed.
<TT>DefineIdn</TT> returns the definition table key bound to the identifier,
while <TT>AddIdn</TT> returns an integer value that is 1 if the specified
binding was added to the set and 0 otherwise.
<P>
The operations that query bindings (<TT>KeyInScope</TT> and <TT>KeyInEnv</TT>) also
take an <TT>Environment</TT> value as a parameter.
<TT>KeyInScope</TT> returns the definition table key bound to the identifier in
the set, if there is one, and returns the distinguished definition table
key <TT>NoKey</TT> if the set contains no binding for the identifier.
<TT>KeyInEnv</TT> behaves the same way except that if there is no binding in the
given set then it examines the related sets as well.
<TT>NoKey</TT> is returned only if there is no binding for the identifier in
<EM>any</EM> related set.
<P>
Consistent renaming for ordinary identifiers must be done on the fly as the
text is read, in order to allow the lexical analyzer to recognize certain
character sequences as <TT>typedef_name</TT>s.
Labels, tags and members need not be distinguished lexically, and therefore
consistent renaming in these name spaces can be deferred until after the
tree is built.
<P>
In order to carry out the consistent renaming process as the input text is
read, the environment module's operations must be invoked during
lexical analysis and parsing.
These invocations must be specified as part of the descriptions of the
lexical analysis and parsing problems for C, using <EM>token processors</EM> and
<EM>connections</EM> respectively.
(A token processor is an arbitrary C routine that is invoked after a
specified character sequence has been recognized.
The name of the routine, enclosed in square brackets, is added to the
specification of the character sequence.
A connection is arbitrary C code that is executed when the parser reduces a
specified production.
The code, enclosed in apostrophes and preceded by an ampersand, is added to
the specification of the production.)
<P>
The keys that were assigned to the ordinary identifiers during parsing are
not stored as values of the <TT>OrdinaryIdDef</TT>, <TT>OrdinaryIdUse</TT>,
<TT>typedef_name</TT> and <TT>UnboundIdUse</TT> terminals
because Eli requires that a parsed terminal have an integer value.
Instead, the keys are stored in array <TT>OrdinaryIdStackArray</TT> and the
index of the array element becomes the value of the terminal.
An array access is therefore needed to obtain the key:
<BLOCKQUOTE>
<A NAME="m182"><I>Access to the key attribute for ordinary identifiers</I>[182]</A>==<BLOCKQUOTE><PRE>
ATTR Key: DefTableKey;

RULE: IdDef ::= OrdinaryIdDef
COMPUTE
  IdDef.Key = OrdinaryIdStackArray(OrdinaryIdDef);
END;

RULE: IdUse ::= OrdinaryIdUse
COMPUTE
  IdUse.Key = OrdinaryIdStackArray(OrdinaryIdUse);
END;

RULE: IdUse ::= UnboundIdUse
COMPUTE
  IdUse.Key = NewKey();
  IF(NOT(IdUse.FunctionId),
    message(ERROR,&quot;Undefined identifier&quot;,0,COORDREF));
END;

ATTR FunctionId: int;

RULE: Expression ::= IdUse
COMPUTE
  IdUse.FunctionId=Expression.FunctionId;
END;

RULE: Expression ::= Expression '(' argument_exp_list ')'
COMPUTE
  Expression[2].FunctionId=1;
END;

RULE: Expression ::= Expression '(' ')'
COMPUTE
  Expression[2].FunctionId=1;
END;

SYMBOL Expression COMPUTE INH.FunctionId=0; END;

RULE: identifier_list LISTOF parameter_id END;
RULE: parameter_id ::= OrdinaryIdDef
COMPUTE
  parameter_id.Key = OrdinaryIdStackArray(OrdinaryIdDef);
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m4">4</A>.
</BLOCKQUOTE>


There are two preconditions for this computation:
the <TT>OrdinaryIdentifier</TT> must have a value,
and the element of <TT>OrdinaryIdStackArray</TT> indexed by that value
must contain the appropriate key.
According to the scope rules of C, the first of these preconditions can be
true and the second false.
<P>
Both preconditions are guaranteed to hold at the time the tree construction
is complete.
Therefore a sufficient condition for correctness of the computation is to
delay it until that time:
<BLOCKQUOTE>
<A NAME="m183"><I>Do not allow attribution during tree construction</I>[183]</A>==<BLOCKQUOTE><PRE>
ORDER: TREE COMPLETE;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m13">13</A>.
</BLOCKQUOTE>


Within the scope of a particular identifier, all occurrences of that
identifier have the same meaning.
The meaning of an identifier is embodied in a number of properties, which
vary depending on the kind of identifier.
For example, a variable identifier might have properties like the type of
the variable and its memory address; an enumeration constant would have a
value.
<P>
Eli provides a central data base called the <EM>definition table</EM>, in which
arbitrary properties can be stored.
The properties of a given entity are queried or updated via a
<EM>definition table key</EM> for that entity.
Thus it is reasonable to represent an identifier by a definition table key,
and store that definition table key in the tree at each occurrence of the
identifier.
Then it is possible to query or update the properties of the identifier
during computations over the tree.
<P>
<EM>Consistent renaming</EM> is the process of associating definition table keys
with occurrences of identifiers:
The identifier is ``renamed'' by the definition table key, and the process
is ``consistent'' because all of the occurrences of an identifier within
its scope are associated with the same definition table key.
<P>
This section defines the code needed to perform consistent renaming in the
ordinary identifier name space of C.
<P>
To implement the scope rules for ordinary identifiers, we provide an
<TT>Environment</TT> value for each set of identifiers that have the same scope.
At the beginning of the scope of an identifier, the parser will add a
binding for that identifier to the current environment.
At the common end of the scopes for identifiers bound in the current
environment, the <TT>Environment</TT> value will be discarded.
<P>
Identifier scopes are nested, as indicated in Section 1.1.2.1.
This means that a stack can be used to store the <TT>Environment</TT> values.
Any operation that creates or queries a binding will use the top element
of that stack as its <TT>Environment</TT> parameter.
The easiest way to obtain such a stack is to create an instance of the
generic stack module that is specialized to store <TT>Environment</TT> values:
<BLOCKQUOTE>
<A NAME="m184"><I>Create a module to stack Environment values</I>[184]</A>==<BLOCKQUOTE><PRE>
$/Adt/Stack.gnrc +instance=Region +referto=Environment :inst
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m10">10</A>.
</BLOCKQUOTE>


Because the <TT>instance</TT> parameter value is <TT>Region</TT>, the operations
exported by this instance of the stack module will be <TT>RegionStackPush</TT>,
<TT>RegionStackPop</TT>, <TT>RegionStackTop</TT>, and so forth.
<P>
The remaining subsections of this section explain how the three scopes
defined by the standard are implemented in this specification.
<A NAME="s8.1"><H2>8.1  File scope</H2></A>

The <TT>Environment</TT> value for all identifiers with file scope
must be created and stored in <TT>RegionStack</TT> before parsing begins,
because an erroneous program might begin with an ordinary identifier and
the environment must be available for the classification algorithm to run:
<BLOCKQUOTE>
<A NAME="m185"><I>Initialize the set of bindings having file scope</I>[185]</A>==<BLOCKQUOTE><PRE>
  RegionStackPush(NewEnv());
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m6">6</A>.
</BLOCKQUOTE>


There is no need to explicitly discard this value, since parsing ends at
the point where the value would be discarded.
Thus there will be no references to <EM>any</EM> <TT>Environment</TT> value beyond
that point.
<A NAME="s8.2"><H2>8.2  Function prototype scope</H2></A>

According to Section 1.1.2.1, a function prototype scope ends at the end
of the function declarator.
Since two identifiers have the same scope if and only if their scopes
terminate at the same point, bindings for all parameter identifiers in a
given declarator should be in the same set and that set should be
associated with the declarator.
Without loss of error detection capability, however, it is possible to
associate the set with a single parameter list.
This fact greatly simplifies the implementation.
<A NAME="s8.2.1"><H3>8.2.1  Constraints on function declarators</H3></A>

Section 6.5.4.3 of the standard states that ``a function declarator shall
not specify a return type that is a function type or an array type.''
Further, it gives the meaning of a declarator containing a parameter list
by postulating a declaration <TT>T D1</TT> in which <TT>D1</TT> has the form
<TT>D(parameter_type_list)</TT> or <TT>D(identifier_list_opt)</TT>.
If the type of <TT>T D</TT> would be ``<TT>some_type T</TT>''
then the type of <TT>T D1</TT> is
``<TT>some_type</TT> function returning <TT>T</TT>''.
<P>
Now suppose that <TT>D</TT> has the same form as <TT>D1</TT>.
Then the type of <TT>T D</TT> would be
``<TT>another_type</TT> function returning <TT>T</TT>'',
so the type of <TT>T D1</TT> would be
``<TT>another_type</TT> function returning function returning <TT>T</TT>''.
Since a function cannot return a function, this type is illegal.
Therefore we must conclude that <TT>D</TT> cannot have the supposed form.
<P>
Section  6.5.4.2 of the standard gives the meaning of a declarator
containing an array bounds expression by postulating a declaration <TT>T D1</TT>
in which <TT>D1</TT> has the form <TT>D[constant_exp_opt]</TT>.
If the type of <TT>T D</TT> would be ``<TT>some_type T</TT>''
then the type of <TT>T D1</TT> is ``<TT>some_type</TT> array of <TT>T</TT>''.
<P>
Now suppose that <TT>D</TT> has the form <TT>D(parameter_type_list)</TT> or
<TT>D(identifier_list_opt)</TT>.
Then the type of <TT>T D</TT> would be
``<TT>another_type</TT> function returning <TT>T</TT>'',
so the type of <TT>T D1</TT> would be
``<TT>another_type</TT> function returning array of <TT>T</TT>''.
Since a function cannot return an array, this type is illegal.
Therefore we must conclude that <TT>D</TT> cannot have the supposed form.
<P>
But if a parameter list can be followed by neither another parameter list
nor an expression in brackets, then it must be the last element of its
declarator according to the grammar.
Therefore the end of the parameter list must coincide with the end of the
declarator.
Finally, if the end of a parameter list coincides with the end of the
declarator then a declarator cannot contain more than one parameter list.
<P>
These constraints are not imposed by the grammar, but they can easily be
checked as the type of an identifier is determined.
The checks depend only on the phrase structure and would not be invalidated
by any error in consistent renaming.
Thus it is safe to consider a function prototype scope to consist only of a
single parameter list.
<A NAME="s8.2.2"><H3>8.2.2  Implementation of function prototype scopes</H3></A>

Since the function prototype scope can be considered to consist only of a
single parameter list, all that is necessary is to push a new environment
at the beginning of the list and discard it at the end.
The <TT>Environment</TT> value must represent a scope nested in the scope
surrounding the parameter list:
<BLOCKQUOTE>
<A NAME="m186"><I>Prototype begin</I>[186]</A>==<BLOCKQUOTE><PRE>
  &amp;'RegionStackPush(NewScope(RegionStackTop));'
</PRE></BLOCKQUOTE>
This macro is invoked in definitions <A HREF="#m14">14</A> and <A HREF="#m156">156</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m187"><I>Prototype end</I>[187]</A>==<BLOCKQUOTE><PRE>
  &amp;'RegionStackPop;'
</PRE></BLOCKQUOTE>
This macro is invoked in definitions <A HREF="#m14">14</A> and <A HREF="#m156">156</A>.
</BLOCKQUOTE>


<A NAME="s8.3"><H2>8.3  Block scope</H2></A>

The ordinary identifiers that have block scope are those whose declarators
appear either inside the block or within the list of parameter declarations
in a function definition.
An <TT>Environment</TT> value for all identifiers in a block scope is therefore
created either at the beginning of the block (if it isn't the block of a
function definition), or at the beginning of the function's parameter list.
In either case, the value is discarded at the end of the block:
<BLOCKQUOTE>
<A NAME="m188"><I>End a compound statement</I>[188]</A>==<BLOCKQUOTE><PRE>
  &amp;'(void)RegionStackPop;'
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m172">172</A>.
</BLOCKQUOTE>


A block that is not part of a function definition gets a new
<TT>Environment</TT> value that represents a scope nested in the surrounding
scope:
<BLOCKQUOTE>
<A NAME="m189"><I>Begin a nested compound statement</I>[189]</A>==<BLOCKQUOTE><PRE>
  &amp;'RegionStackPush(NewScope(RegionStackTop));'
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m170">170</A>.
</BLOCKQUOTE>


If the block is part of a function definition, then it must use the
<TT>Environment</TT> value that was used for the function prototype scope of the
function's parameters.
If the program is syntactically incorrect, however, there may be no such
<TT>Environment</TT> value and a new nested scope must be created.
Determination of the appropriate <TT>Environment</TT> value for a function body
is a rather complex process, and therefore we embed it in a module:
<BLOCKQUOTE>
<A NAME="m190"><I>Function definition</I>[190]</A>==<BLOCKQUOTE><PRE>
  &amp;'RegionStackPush(FunctionEnv(RegionStackTop));'
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m178">178</A>.
</BLOCKQUOTE>


<A NAME="s8.3.1"><H3>8.3.1  Determining the function environment</H3></A>

The syntactic structure of a C function definition does not reflect the
scope rules.
A function definition may contain an arbitrary number of
<TT>parameter_part</TT>s, some embedded in type specifiers and others in the
declarator.
The specific <TT>parameter_part</TT> declaring ordinary identifiers to be
parameters of the function can be determined from the tree structure,
but the tree structure is not available during parsing.
Therefore the parser must use an alternative method, based only on left
context, to select the appropriate <TT>parameter_part</TT>.
<P>
A <TT>function_definition</TT> is an <TT>external_declaration</TT>.
Therefore the left context of interest does not extend beyond the beginning
of an external declaration:
<BLOCKQUOTE>
<A NAME="m191"><I>Begin an external declaration</I>[191]</A>==<BLOCKQUOTE><PRE>
  &amp;'NewDeclaration();'
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m177">177</A>.
</BLOCKQUOTE>


Function declarators always appear at the ``top level'' of an
<TT>external_declaration</TT>, and hence a <TT>declarator</TT> appearing within
a <TT>component_list</TT> or a <TT>parameter_type_list</TT>
is uninteresting in this computation:
<BLOCKQUOTE>
<A NAME="m192"><I>Begin a component_list</I>[192]</A>==<BLOCKQUOTE><PRE>
  &amp;'BeginNestedDecl();'
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m29">29</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m193"><I>End a component_list</I>[193]</A>==<BLOCKQUOTE><PRE>
  &amp;'EndNestedDecl();'
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m29">29</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m194"><I>Begin a parameter_type_list</I>[194]</A>==<BLOCKQUOTE><PRE>
  &amp;'BeginNestedDecl();'
</PRE></BLOCKQUOTE>
This macro is invoked in definitions <A HREF="#m14">14</A> and <A HREF="#m156">156</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m195"><I>End a parameter_type_list</I>[195]</A>==<BLOCKQUOTE><PRE>
  &amp;'EndNestedDecl();'
</PRE></BLOCKQUOTE>
This macro is invoked in definitions <A HREF="#m14">14</A> and <A HREF="#m156">156</A>.
</BLOCKQUOTE>


If a declarator specifies an array type to the left of the first
specification of a function type, then that declarator is not a function
declarator:
<BLOCKQUOTE>
<A NAME="m196"><I>Array declarator</I>[196]</A>==<BLOCKQUOTE><PRE>
  &amp;'ArrayOrPointerDecl();'
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m155">155</A>.
</BLOCKQUOTE>


Similarly, if a declarator specifies a pointer then no enclosing declarator
is a function declarator:
<BLOCKQUOTE>
<A NAME="m197"><I>Pointer declarator</I>[197]</A>==<BLOCKQUOTE><PRE>
  &amp;'ArrayOrPointerDecl();'
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m153">153</A>.
</BLOCKQUOTE>


Depending upon the context, any parameter list might be the parameter list
of a function definition.
If so, then the <TT>Environment</TT> value for that parameter list will be the
<TT>Environment</TT> value for the function body:
<BLOCKQUOTE>
<A NAME="m198"><I>Begin a parameter list</I>[198]</A>==<BLOCKQUOTE><PRE>
  &amp;'FunctionDecl(RegionStackTop);'
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m156">156</A>.
</BLOCKQUOTE>


<A NAME="s8.3.2"><H3>8.3.2  Implementing the declaration state</H3></A>

The heart of the declaration state computation is a variable that
distinguishes four possible states:
<BLOCKQUOTE>
<A NAME="m199"><I>State variable definitions</I>[199]</A>==<BLOCKQUOTE><PRE>
typedef enum {
  UnknownDecl,
  IsFunction,
  NotFunction,
  IsNested
} DeclarationStateValues;

static int DeclarationState;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m199">199</A>, <A HREF="#m200">200</A>, <A HREF="#m201">201</A>, <A HREF="#m202">202</A>, <A HREF="#m203">203</A>, <A HREF="#m207">207</A>, and <A HREF="#m213">213</A>.<BR>
This macro is invoked in definition <A HREF="#m6">6</A>.
</BLOCKQUOTE>


Arbitrary nesting depth can be handled without a stack by incrementing the
current value of <TT>DeclarationState</TT> by <TT>IsNested</TT>:
A value greater than or equal to <TT>IsNested</TT> indicates the nested state,
but the state at the top level is also preserved.
This is the reason that <TT>DeclarationState</TT> cannot be declared as a
variable of type <TT>DeclarationStateValues</TT>; with arbitrary nesting,
<TT>DeclarationState</TT> takes on values that are not valid
<TT>DeclarationStateValues</TT>.
<BLOCKQUOTE>
<A NAME="m200"><I>State variable definitions</I>[200]</A>==<BLOCKQUOTE><PRE>
void BeginNestedDecl() { DeclarationState += IsNested; }
void EndNestedDecl() { DeclarationState -= IsNested; }
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m199">199</A>, <A HREF="#m200">200</A>, <A HREF="#m201">201</A>, <A HREF="#m202">202</A>, <A HREF="#m203">203</A>, <A HREF="#m207">207</A>, and <A HREF="#m213">213</A>.<BR>
This macro is invoked in definition <A HREF="#m6">6</A>.
</BLOCKQUOTE>


The state is reset at the beginning of each external definition:
<BLOCKQUOTE>
<A NAME="m201"><I>State variable definitions</I>[201]</A>==<BLOCKQUOTE><PRE>
void NewDeclaration() { DeclarationState = UnknownDecl; }
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m199">199</A>, <A HREF="#m200">200</A>, <A HREF="#m201">201</A>, <A HREF="#m202">202</A>, <A HREF="#m203">203</A>, <A HREF="#m207">207</A>, and <A HREF="#m213">213</A>.<BR>
This macro is invoked in definition <A HREF="#m6">6</A>.
</BLOCKQUOTE>


When the parser reaches a specification of a pointer, array or function it
can decide whether it is dealing with a function definition or not.
That decision is made on the basis of the <EM>leftmost</EM> such specification
that is at the top level.
In other words, a decision can only be made in the <TT>UnknownDecl</TT> state:
<BLOCKQUOTE>
<A NAME="m202"><I>State variable definitions</I>[202]</A>==<BLOCKQUOTE><PRE>
void ArrayOrPointerDecl()
{ if (DeclarationState == UnknownDecl) DeclarationState = NotFunction; }

static Environment FunctionEnvironment;

void
#if PROTO_OK
FunctionDecl(Environment Env)
#else
FunctionDecl(Env) Environment Env;
#endif
{ if (DeclarationState == UnknownDecl) {
    DeclarationState = IsFunction;
    FunctionEnvironment = Env;
  }
}
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m199">199</A>, <A HREF="#m200">200</A>, <A HREF="#m201">201</A>, <A HREF="#m202">202</A>, <A HREF="#m203">203</A>, <A HREF="#m207">207</A>, and <A HREF="#m213">213</A>.<BR>
This macro is invoked in definition <A HREF="#m6">6</A>.
</BLOCKQUOTE>


If the state is <TT>IsFunction</TT> when the function body is reached, then
<TT>FunctionEnvironment</TT> is the appropriate <TT>Environment</TT> value.
Otherwise a new value representing a scope nested in the current scope
must be created:
<BLOCKQUOTE>
<A NAME="m203"><I>State variable definitions</I>[203]</A>==<BLOCKQUOTE><PRE>
Environment
#if PROTO_OK
FunctionEnv(Environment Env)
#else
FunctionEnv(Env) Environment Env;
#endif
{ if (DeclarationState == IsFunction) return FunctionEnvironment;
  return NewScope(Env);
}
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m199">199</A>, <A HREF="#m200">200</A>, <A HREF="#m201">201</A>, <A HREF="#m202">202</A>, <A HREF="#m203">203</A>, <A HREF="#m207">207</A>, and <A HREF="#m213">213</A>.<BR>
This macro is invoked in definition <A HREF="#m6">6</A>.
</BLOCKQUOTE>


The interface to this module must include the interface to the environment
module:
<BLOCKQUOTE>
<A NAME="m204"><I>State variable declarations</I>[204]</A>==<BLOCKQUOTE><PRE>
#include &quot;envmod.h&quot;

extern void BeginNestedDecl ELI_ARG((void));
extern void EndNestedDecl ELI_ARG((void));
extern void NewDeclaration ELI_ARG((void));
extern void FunctionDecl ELI_ARG((Environment Env));
extern Environment FunctionEnv ELI_ARG((Environment Env));
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m204">204</A>, <A HREF="#m208">208</A>, and <A HREF="#m212">212</A>.<BR>
This macro is invoked in definition <A HREF="#m7">7</A>.
</BLOCKQUOTE>


<A NAME="s8.4"><H2>8.4  Occurrences of ordinary identifiers</H2></A>

An applied occurrence of an ordinary identifier that has been declared as
the name of a type is represented in the grammar by the terminal symbol
<TT>typedef_name</TT>.
It is necessary to distinguish other applied occurrences of ordinary
identifiers from occurrences of labels, tags and member identifiers
because the consistent renaming process has been carried out
for ordinary identifiers during parsing,
and therefore an ordinary identifier has an associated definition table key.
Labels, tags and members do not have definition table keys until the
tree computation implementing the consistent renaming process for their
respective name spaces has been completed.
Therefore an applied occurrence of an ordinary identifier that has been
declared as a variable, function, parameter or enumeration constant is
represented in the grammar by the terminal symbol <TT>OrdinaryIdUse</TT>.
<P>
The lexical analyzer actions needed at the defining occurrences of ordinary
identifiers are different from those needed at applied ocurrences.
Thus the lexical analyzer must be able to determine when it is dealing with a
defining occurrence of an ordinary identifier.
If we represent the defining occurrence of an ordinary identifier in the
grammar by yet another terminal symbol, <TT>OrdinaryIdDef</TT>, then the lexical
analyzer will know that it is dealing with a defining occurrence of an
ordinary identifier if the parser will accept the symbol <TT>OrdinaryIdDef</TT>.
<P>
An identifier can be used as the name of an external function even though
that identifier has not been declared.
Such an identifier can occur only in an expression context, and that
context must also be represented by a special terminal symbol,
<TT>UnboundIdUse</TT>, to provide the necessary information to the lexical
analyzer.
<P>
Thus this specification defines three terminal symbols for identifiers in
addition to the two (<TT>identifier</TT> and <TT>typedef_name</TT>) used by the standard:
<BLOCKQUOTE>
<A NAME="m205"><I>Additional terminal symbols representing identifiers</I>[205]</A>==<BLOCKQUOTE><PRE>
OrdinaryIdUse:  $[_a-zA-Z][_a-zA-Z0-9]*
OrdinaryIdDef:  $[_a-zA-Z][_a-zA-Z0-9]*
UnboundIdUse:   $[_a-zA-Z][_a-zA-Z0-9]*
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m16">16</A>.
</BLOCKQUOTE>


<A NAME="s8.4.1"><H3>8.4.1  Ordinary identifiers and the definition table</H3></A>

Because Eli allows only integers as values for parsed terminals, it is not
possible to represent ordinary identifiers by definition table keys.
Instead, the specification defines an array of definition table keys, with
one element for each defining occurrence and one element for all undefined
ordinary identifiers.
The representation of an ordinary identifier leaf is the index of the
element for the corresponding defining occurrence.
<P>
Since the size of the array cannot be known a priori, it is implemented by
a stack:
<BLOCKQUOTE>
<A NAME="m206"><I>Create a module to stack DefTableKey values</I>[206]</A>==<BLOCKQUOTE><PRE>
$/Adt/Stack.gnrc +instance=OrdinaryId +referto=DefTableKey :inst
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m10">10</A>.
</BLOCKQUOTE>


A state variable keeps track of the index of the next element to be
allocated on the stack, which is initialized with one element specifying
the distinguished definition table key <TT>NoKey</TT>.
<TT>NoKey</TT> is the definition table key assigned to undefined identifiers:
<BLOCKQUOTE>
<A NAME="m207"><I>State variable definitions</I>[207]</A>==<BLOCKQUOTE><PRE>
int NextKeyIndex = 1;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m199">199</A>, <A HREF="#m200">200</A>, <A HREF="#m201">201</A>, <A HREF="#m202">202</A>, <A HREF="#m203">203</A>, <A HREF="#m207">207</A>, and <A HREF="#m213">213</A>.<BR>
This macro is invoked in definition <A HREF="#m6">6</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m208"><I>State variable declarations</I>[208]</A>==<BLOCKQUOTE><PRE>
extern int NextKeyIndex;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m204">204</A>, <A HREF="#m208">208</A>, and <A HREF="#m212">212</A>.<BR>
This macro is invoked in definition <A HREF="#m7">7</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m209"><I>Initialize the array of definition table keys</I>[209]</A>==<BLOCKQUOTE><PRE>
  OrdinaryIdStackPush(NoKey);
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m6">6</A>.
</BLOCKQUOTE>


The value of <TT>NextKeyIndex</TT> at any time is the number of elements in
<TT>OrdinaryIdStack</TT>.
In order to maintain this invariant,
two actions are needed whenever a new key is allocated:
<BLOCKQUOTE>
<A NAME="m210"><I>New key</I>[210]</A>==<BLOCKQUOTE><PRE>IdState.Index=NextKeyIndex++; OrdinaryIdStackPush(NoKey);</PRE></BLOCKQUOTE>
This macro is invoked in definitions <A HREF="#m222">222</A> and <A HREF="#m224">224</A>.
</BLOCKQUOTE>


Each defined ordinary identifier has three properties that must be
established during parsing: a <EM>symbol</EM>, a <EM>syntax code</EM> and an <EM>index</EM>.
The symbol is the index of the identifier's string in the character string
memory array.  Each string is stored exactly once, so the the values of the
symbols for two identifiers with the same spelling will be the same.
The syntax code is the integer classification of the identifier,
and is always either <TT>typedef_name</TT> or <TT>OrdinaryIdUse</TT>.
The index is the index of the definition table key in the array of defining
occurrences.
<BLOCKQUOTE>
<A NAME="m211"><I>Properties of ordinary identifiers used during parsing</I>[211]</A>==<BLOCKQUOTE><PRE>
Symbol, SynCode, Index: int;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m9">9</A>.
</BLOCKQUOTE>


<A NAME="s8.4.2"><H3>8.4.2  State information for an ordinary identifier definition</H3></A>

In order to correctly define an ordinary identifier, state information must
be retained to relate actions by the lexical analyzer and actions by the parser.
The necessary information is exactly the set of properties for the
identifier:
<BLOCKQUOTE>
<A NAME="m212"><I>State variable declarations</I>[212]</A>==<BLOCKQUOTE><PRE>
typedef struct {
  int Symbol, SynCode, Index;
} IdProperties;

extern IdProperties IdState;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m204">204</A>, <A HREF="#m208">208</A>, and <A HREF="#m212">212</A>.<BR>
This macro is invoked in definition <A HREF="#m7">7</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m213"><I>State variable definitions</I>[213]</A>==<BLOCKQUOTE><PRE>
IdProperties IdState;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m199">199</A>, <A HREF="#m200">200</A>, <A HREF="#m201">201</A>, <A HREF="#m202">202</A>, <A HREF="#m203">203</A>, <A HREF="#m207">207</A>, and <A HREF="#m213">213</A>.<BR>
This macro is invoked in definition <A HREF="#m6">6</A>.
</BLOCKQUOTE>


<TT>IdState</TT> is a global variable that reflects the state information for
the last defining occurrence of an ordinary identifier.
The standard specifies (Section 6.1.2.1) that a defining occurrence is
bound to a definition table key at the end of the declarator in which it
appears (unless it is an <TT>enumeration_constant</TT>).
An arbitrary number of other defining occurrences may appear between a
particular defining occurrence and the point at which it is bound.
Therefore a stack must be used to save <TT>IdState</TT> until the identifier it
describes can be bound:
<BLOCKQUOTE>
<A NAME="m214"><I>Create a module to stack identifier state values</I>[214]</A>==<BLOCKQUOTE><PRE>
$/Adt/Stack.gnrc +instance=IdState +referto=IdProperties :inst
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m10">10</A>.
</BLOCKQUOTE>


The value of <TT>IdState.Symbol</TT> is set by the lexical analyzer for
each occurrence of an identifier, and that of <TT>IdState.Index</TT> is set by
the parser when it has accepted a defining occurrence of an ordinary
identifier.
<TT>IdState.SynCode</TT> is initialized to <TT>OrdinaryIdUse</TT>, and reset to that
value by the parser whenever the end of a <TT>declaration</TT> is reached:
<BLOCKQUOTE>
<A NAME="m215"><I>Initialize the class of ordinary identifiers</I>[215]</A>==<BLOCKQUOTE><PRE>
  IdState.SynCode = OrdinaryIdUse;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m12">12</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m216"><I>End of a declaration</I>[216]</A>==<BLOCKQUOTE><PRE>
  &amp;'IdState.SynCode = OrdinaryIdUse;'
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m127">127</A>.
</BLOCKQUOTE>


When the parser accepts the storage class specifier <TT>typedef</TT>, it sets
<TT>IdState.SynCode</TT> to <TT>typedef_name</TT>.
This setting will persist until the end of the <TT>declaration</TT> containing
the <TT>typedef</TT>:
<BLOCKQUOTE>
<A NAME="m217"><I>A typedef storage class specifier has been accepted</I>[217]</A>==<BLOCKQUOTE><PRE>
  &amp;'IdState.SynCode = typedef_name;'
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m132">132</A>.
</BLOCKQUOTE>


An <TT>enumeration_constant</TT> is never a <TT>typedef_name</TT>, even when the
enumeration specifier follows a typedef <TT>storage_class_specifier</TT>:
<BLOCKQUOTE>
<A NAME="m218"><I>Begin a list of enumeration constants</I>[218]</A>==<BLOCKQUOTE><PRE>
  &amp;'IdStateStackPush(IdState); IdState.SynCode = OrdinaryIdUse;'
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m142">142</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m219"><I>End a list of enumeration constants</I>[219]</A>==<BLOCKQUOTE><PRE>
  &amp;'IdState = IdStateStackPop;'
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m142">142</A>.
</BLOCKQUOTE>


<A NAME="s8.4.3"><H3>8.4.3  Classifying occurrences of identifiers</H3></A>

The lexical analyzer must classify each character sequence that matches the
definition of <TT>identifier</TT> as one of the five terminal symbols
<TT>identifier</TT>, <TT>typedef_name</TT>, <TT>OrdinaryIdUse</TT>, <TT>OrdinaryIdDef</TT>
or <TT>UnboundIdUse</TT>.
It does this by means of the token processor <TT>IdnOrType</TT>:
<BLOCKQUOTE>
<A NAME="m220"><I>Initial classification of identifier terminals</I>[220]</A>==<BLOCKQUOTE><PRE>
void
#if PROTO_OK
IdnOrType(char *start, int length, int *syncode, int *rep)
#else
IdnOrType(start, length, syncode, rep)
char *start; int length, *syncode; int *rep;
#endif
/* Obtain the internal coding of an identifier
 *    On entry-
 *       start points to the character string for the identifier
 *       length=length of the character string for the identifier
 *       syncode points to a location containing the initial terminal code
 *    On exit-
 *       syncode has been set to the terminal code
 *       rep has been set to the internal coding
 ***/
{ DefTableKey key;

  mkidn(start, length, syncode, &amp;(IdState.Symbol));
  key = KeyInEnv(RegionStackTop, IdState.Symbol);
  *syncode = GetSynCode(key, UnboundIdUse);
  *rep = GetIndex(key, IdState.Symbol);
}
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m6">6</A>.
</BLOCKQUOTE>


<TT>IdnOrType</TT> first uses <TT>mkidn</TT> to obtain the index of the character
sequence in the character string memory array, placing that index into the
state variable component <TT>IdState.Symbol</TT>.
Next, the index is looked up in the <TT>RegionStackTop</TT> environment to
obtain the corresponding definition table key (if one exists).
The <TT>SynCode</TT> and <TT>Index</TT> properties of that definition table key
are then queried, and the results of the queries become
the classification of the terminal symbol and
the representation respectively.
Since <TT>UnboundIdUse</TT> is specified as the default value for the <TT>SynCode</TT>
query, the terminal symbol will be classified as an <TT>UnboundIdUse</TT>
unless a previous binding is visible in the current environment.
Similarly, if there is no visible binding, the representation will be set
to the value of the state variable <TT>NextKeyIndex</TT>.
<P>
The classification determined by <TT>IdnOrType</TT> may or may not fit the
current context.
If it does fit, then the parser will accept the terminal symbol and
continue.
If it does not fit, the parser will invoke the function <TT>Reparatur</TT>:
<BLOCKQUOTE>
<A NAME="m221"><I>Re-classify an identifier terminal to fit the context</I>[221]</A>==<BLOCKQUOTE><PRE>
int
#if PROTO_OK
Reparatur(POSITION *coord, int *syncode, int *rep)
#else
Reparatur(coord, syncode, rep)
POSITION *coord;
int *syncode, *rep;
#endif
/* Repair a syntax error by changing the lookahead token
 *   On entry-
 *     coord points to the coordinates of the lookahead token
 *     syncode points to the classification of the lookahead token
 *     rep points to the representation of the lookahead token
 *   If the lookahead token has been changed then on exit-
 *     Reparatur=1
 *     coord, syncode and rep reflect the change
 *   Else on exit-
 *     Reparatur=0
 *     coord, syncode and rep are unchanged
 ***/
{
  if (*syncode == typedef_name ||
      *syncode == OrdinaryIdUse ||
      *syncode == UnboundIdUse) {
    *syncode = OrdinaryIdDef;
    *rep = NextKeyIndex;
    return 1;
  }
  if (*syncode != OrdinaryIdDef) return 0;
  *syncode = identifier;
  *rep = IdState.Symbol;
  return 1;
}
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m6">6</A>.
</BLOCKQUOTE>


If the original classification was based on a visible definition,
or if the identifier had not been previously classified, then
<TT>Reparatur</TT> re-classifies the symbol as a defining occurrence of an
ordinary identifier.
Again, the parser will either accept the terminal symbol with this
classification or invoke <TT>Reparatur</TT>.
If <TT>Reparatur</TT> is invoked with the previous classification being a
defining occurrence of an ordinary identifier, then it re-classifies the
symbol as an identifier in one of the other name spaces (label, tag or
member).
<A NAME="s8.4.4"><H3>8.4.4  Establishing bindings for ordinary identifiers</H3></A>

In order to establish the binding for an ordinary identifier, the parser
must complete the identifier's state when the defining occurrence has been
accepted or when the identifier has been accepted as unbound.
<P>
In some constructs the state must be saved and the actual binding made
when the end of that construct is reached; in other cases the binding must
be done immediately.
<BLOCKQUOTE>
<A NAME="m222"><I>Defer binding the declared identifier</I>[222]</A>==<BLOCKQUOTE><PRE>
  &amp;'<A HREF="#m210"><I>New key</I>[210]</A> IdStateStackPush(IdState);'
</PRE></BLOCKQUOTE>
This macro is invoked in definitions <A HREF="#m51">51</A> and <A HREF="#m155">155</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m223"><I>Carry out a deferred binding</I>[223]</A>==<BLOCKQUOTE><PRE>
  &amp;'IdState = IdStateStackPop; Bind();'
</PRE></BLOCKQUOTE>
This macro is invoked in definitions <A HREF="#m25">25</A> and <A HREF="#m26">26</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m224"><I>Bind the identifier immediately</I>[224]</A>==<BLOCKQUOTE><PRE>
  &amp;'<A HREF="#m210"><I>New key</I>[210]</A> Bind();'
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m158">158</A>.
</BLOCKQUOTE>


In either case, the actual binding process is embedded in a function
because of its relative complexity:
<BLOCKQUOTE>
<A NAME="m225"><I>Bind a defining occurrence of an ordinary identifier</I>[225]</A>==<BLOCKQUOTE><PRE>
void
Bind()
{ DefTableKey key;

  key = DefineIdn(RegionStackTop, IdState.Symbol);
  ResetSymbol(key, IdState.Symbol);
  ResetSynCode(key, IdState.SynCode);
  ResetIndex(key, IdState.Index);
  OrdinaryIdStackArray(IdState.Index) = key;
}
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m6">6</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m226"><I>Operation interfaces</I>[226]</A>==<BLOCKQUOTE><PRE>
extern void Bind();
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m226">226</A>.<BR>
This macro is invoked in definition <A HREF="#m7">7</A>.
</BLOCKQUOTE>

<A NAME="s9"><H1>9  Internal Representation of Types</H1></A>

Each distinct type is represented internally by a distinct definition table
key.
Relationships among types are represented by <TT>DefTableKey</TT>-valued
properties.
Other characteristics, such as whether or not the type is complete,
are also represented by appropriate properties.
This chapter describes the structure of the internal representation, and
the operations used to maintain it.
<A NAME="s9.1"><H2>9.1  Creating type representations</H2></A>

The generated processor maintains a run-time data structure separate from
the tree to represent the types used in a particular program.
This section describes the content of that run-time data structure and
provides operational specifications for the routines that maintain it.
The discussion follows Section 6.1.2.5 of the standard.
<A NAME="s9.1.1"><H3>9.1.1  Properties of types</H3></A>

The basic types are named in the OIL specification that describes the type
model.
A definition table key is used as the OIL name.
<P>
Every type has the <TT>isComplete</TT> property, whose value is <TT>0</TT> if the
type is incomplete and <TT>1</TT> otherwise.
<BLOCKQUOTE>
<A NAME="m227"><I>Properties of types</I>[227]</A>==<BLOCKQUOTE><PRE>
isComplete: int;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m227">227</A>, <A HREF="#m228">228</A>, <A HREF="#m230">230</A>, <A HREF="#m235">235</A>, <A HREF="#m237">237</A>, <A HREF="#m238">238</A>, and <A HREF="#m239">239</A>.<BR>
This macro is invoked in definition <A HREF="#m244">244</A>.
</BLOCKQUOTE>


<A NAME="s9.1.2"><H3>9.1.2  Array type</H3></A>

If <TT>T</TT> is the element type of one or more array types, then those types
have the key of an incomplete array type <TT>T [ ]</TT> as the value of their
<TT>ArrayOf</TT> property.
The array type <TT>T [ ]</TT> has the key of the element type <TT>T</TT> as the value
of its <TT>ElementType</TT> property.
This specification does not distinguish array types by size.
<BLOCKQUOTE>
<A NAME="m228"><I>Properties of types</I>[228]</A>==<BLOCKQUOTE><PRE>
ElementType: DefTableKey;
ArrayOf:     DefTableKey;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m227">227</A>, <A HREF="#m228">228</A>, <A HREF="#m230">230</A>, <A HREF="#m235">235</A>, <A HREF="#m237">237</A>, <A HREF="#m238">238</A>, and <A HREF="#m239">239</A>.<BR>
This macro is invoked in definition <A HREF="#m244">244</A>.
</BLOCKQUOTE>


<TT>KeyForArray</TT> accepts the definition table key for an element type <TT>T</TT>
and returns the corresponding incomplete array type:
<BLOCKQUOTE>
<A NAME="m229"><I>Array type</I>[229]</A>==<BLOCKQUOTE><PRE>
if ((ArrayKey = GetArrayOf(T, NoKey)) == NoKey) {
  ArrayKey = NewKey();
  ResetOilType(
    ArrayKey,
    OilClassInst2(
      OilClassTypeIs_Array,
      ArrayKey,
      GetOilType(T, OilErrorType()),
      GetOilType(KeyForPointer(T), OilErrorType())));
  ResetArrayOf(T, ArrayKey);
  ResetElementType(ArrayKey, T);
}
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m241">241</A>.
</BLOCKQUOTE>


<A NAME="s9.1.3"><H3>9.1.3  Function type</H3></A>

If <TT>T</TT> is the type returned by one or more functions, then that type
has the key of a function type <TT>T ()</TT> as the value of its
<TT>FunctionReturning</TT> property.
<TT>T</TT> is the value of the <TT>ReturnType</TT> property of the function type.
This specification does not distinguish function types by argument
signatures.
<BLOCKQUOTE>
<A NAME="m230"><I>Properties of types</I>[230]</A>==<BLOCKQUOTE><PRE>
FunctionReturning: DefTableKey;
ReturnType       : DefTableKey;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m227">227</A>, <A HREF="#m228">228</A>, <A HREF="#m230">230</A>, <A HREF="#m235">235</A>, <A HREF="#m237">237</A>, <A HREF="#m238">238</A>, and <A HREF="#m239">239</A>.<BR>
This macro is invoked in definition <A HREF="#m244">244</A>.
</BLOCKQUOTE>


<TT>KeyForFunction</TT> accepts the definition table key for a return type <TT>T</TT>
and returns the corresponding function type:
<BLOCKQUOTE>
<A NAME="m231"><I>Function type</I>[231]</A>==<BLOCKQUOTE><PRE>
if ((FunctionKey = GetFunctionReturning(T, NoKey)) == NoKey) {
  tOilType functionType, pointerType;

  FunctionKey = NewKey();
  functionType=
    OilClassInst1(
      OilClassTypeIs_Function,
      FunctionKey,
      GetOilType(T, OilErrorType()));
  ResetOilType(FunctionKey,functionType);
  pointerType=GetOilType(KeyForPointer(FunctionKey), OilErrorType());
  OilAddCoercion(
    OilNewOp(
      CFunctoPtr,
      OilAddArgSig(pointerType, OilAddArgSig(functionType, OilNewArgSig())),
      1));
  ResetReturnType(FunctionKey, T);
  ResetFunctionReturning(T, FunctionKey);
  ResetKind(FunctionKey, Kind_function);
}
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m241">241</A>.
</BLOCKQUOTE>


There are three different types of parameter lists.  The first type is
the <TT>Unspecified</TT> type, which corresponds to a non-ANSI declaration,
where no signature is given.  The second type, <TT>ExplicitAndFixed</TT>
is the normal ANSI declaration, where the number of parameters given
is explicit (i.e. it won't change).  The third type is the variable
declaration, and it's called <TT>ExplicitAndVariable</TT>.
<BLOCKQUOTE>
<A NAME="m232"><I>Modifier types</I>[232]</A>==<BLOCKQUOTE><PRE>
typedef enum {
  Unspecified,
  ExplicitAndFixed,
  ExplicitAndVariable
} TypeOfSignature;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m240">240</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m233"><I>Attributes for type computations</I>[233]</A>==<BLOCKQUOTE><PRE>
ATTR  Type:        DefTableKey;
ATTR  FQSignature: int;
ATTR  Signature:   KeyArray;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m243">243</A>.
</BLOCKQUOTE>


<TT>FQSignature</TT> and <TT>Signature</TT> are used
presently to determine the signature of a parameter list, but may
change in the future if something more appropriate is found.
<BLOCKQUOTE>
<A NAME="m234"><I>Parameter signature computations</I>[234]</A>==<BLOCKQUOTE><PRE>
SYMBOL parameter_part
COMPUTE
  SYNT.Signature   = NoKeyArray;
  SYNT.FQSignature = ExplicitAndFixed;
END;

SYMBOL parameter_type_list_opt
COMPUTE
  THIS.Signature   = NoKeyArray;
  THIS.FQSignature = ExplicitAndFixed;
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m243">243</A>.
</BLOCKQUOTE>


<A NAME="s9.1.4"><H3>9.1.4  Pointer type</H3></A>

If <TT>T</TT> is the type referenced by a pointer, then that type
has the key of the pointer type  <TT>T *</TT> as the value of its
<TT>PointedToBy</TT> property.
<TT>T</TT> is the value of the <TT>BaseType</TT> property of the pointer type.
<BLOCKQUOTE>
<A NAME="m235"><I>Properties of types</I>[235]</A>==<BLOCKQUOTE><PRE>
BaseType   : DefTableKey;
PointedToBy: DefTableKey;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m227">227</A>, <A HREF="#m228">228</A>, <A HREF="#m230">230</A>, <A HREF="#m235">235</A>, <A HREF="#m237">237</A>, <A HREF="#m238">238</A>, and <A HREF="#m239">239</A>.<BR>
This macro is invoked in definition <A HREF="#m244">244</A>.
</BLOCKQUOTE>


<TT>KeyForPointer</TT> accepts the definition table key for a referenced type
<TT>T</TT> and returns the corresponding pointer type:
<BLOCKQUOTE>
<A NAME="m236"><I>Pointer type</I>[236]</A>==<BLOCKQUOTE><PRE>
if ((PtrKey = GetPointedToBy(T, NoKey)) == NoKey) {
  PtrKey = NewKey();
  ResetOilType(
    PtrKey,
    OilClassInst1(
      OilClassTypeIs_Pointer,
      PtrKey,
      GetOilType(T, OilErrorType())));
  ResetisComplete(PtrKey, 1);
  ResetPointedToBy(T, PtrKey);
  ResetBaseType(PtrKey, T);
}
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m241">241</A>.
</BLOCKQUOTE>


<A NAME="s9.1.5"><H3>9.1.5  Qualified type</H3></A>

Any type so far mentioned is an <EM>unqualified type</EM>.
Each unqualified type has three corresponding <EM>qualified versions</EM> of its
type: a <EM>const-qualified</EM> version, a <EM>volatile qualified</EM> version, and
a version having both qualifications.
The qualified and unqualified versions of a type are distinct types that
belong to the same type category.
<P>
If the unqualified version of a type has either the <TT>isConst</TT> or
<TT>isVolatile</TT> property, their values are <TT>0</TT>.
Qualified versions of the type have the appropriate properties with the
value <TT>1</TT>.
If a qualified version of a type has an inappropriate property, the value
of that property is <TT>0</TT>.
(Thus a const-qualified type has the <TT>isConst</TT> property with value <TT>1</TT>;
it may or may not have the <TT>isVolatile</TT> property, but if that property is
present then its value is <TT>0</TT>.)
<BLOCKQUOTE>
<A NAME="m237"><I>Properties of types</I>[237]</A>==<BLOCKQUOTE><PRE>
isConst           : int;
isVolatile        : int;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m227">227</A>, <A HREF="#m228">228</A>, <A HREF="#m230">230</A>, <A HREF="#m235">235</A>, <A HREF="#m237">237</A>, <A HREF="#m238">238</A>, and <A HREF="#m239">239</A>.<BR>
This macro is invoked in definition <A HREF="#m244">244</A>.
</BLOCKQUOTE>


If qualified versions of a type exist, the unqualified version also
exists.
The definition table key for each qualified version is the value of the
appropriate property (<TT>ConstType</TT>, <TT>VolatileType</TT> or
<TT>ConstVolatileType</TT>) of the unqualified version.
Every qualified version of a type has the definition table key of the
unqualified version of that type as the value of the <TT>UnqualifiedType</TT>
property.
<BLOCKQUOTE>
<A NAME="m238"><I>Properties of types</I>[238]</A>==<BLOCKQUOTE><PRE>
UnqualifiedType   : DefTableKey;
ConstType         : DefTableKey;
VolatileType      : DefTableKey;
ConstVolatileType : DefTableKey;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m227">227</A>, <A HREF="#m228">228</A>, <A HREF="#m230">230</A>, <A HREF="#m235">235</A>, <A HREF="#m237">237</A>, <A HREF="#m238">238</A>, and <A HREF="#m239">239</A>.<BR>
This macro is invoked in definition <A HREF="#m244">244</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m239"><I>Properties of types</I>[239]</A>==<BLOCKQUOTE><PRE>
Type              : DefTableKey;
Kind              : int [Is];          
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m227">227</A>, <A HREF="#m228">228</A>, <A HREF="#m230">230</A>, <A HREF="#m235">235</A>, <A HREF="#m237">237</A>, <A HREF="#m238">238</A>, and <A HREF="#m239">239</A>.<BR>
This macro is invoked in definition <A HREF="#m244">244</A>.
</BLOCKQUOTE>


<A NAME="s9.2"><H2>9.2  Specification files</H2></A>

<A NAME="s9.2.1"><H3>9.2.1  buildtype.h</H3></A>

<BLOCKQUOTE>
<A NAME="m240"><B>buildtype.h</B>[240]</A>==<BLOCKQUOTE><PRE>
#ifndef BUILDTYPE_H
#define BUILDTYPE_H

#include &lt;stdio.h&gt;
#include &quot;eliproto.h&quot;  /* determines if we can use prototypes */
#include &quot;type.h&quot;
#include &quot;IntSet.h&quot;
#include &quot;pdl_gen.h&quot;
#include &quot;deftbl.h&quot;
#include &quot;err.h&quot;     /* for error stuff */
#include &quot;keyarray.h&quot;

<A HREF="#m232"><I>Modifier types</I>[232]</A>

extern DefTableKey KeyForArray         ELI_ARG((DefTableKey));
extern DefTableKey KeyForFunction      ELI_ARG((DefTableKey));
extern DefTableKey KeyForPointer       ELI_ARG((DefTableKey));
extern DefTableKey KeyForQualifier     ELI_ARG((DefTableKey, int, int));
extern DefTableKey KeyForEnum          ELI_ARG((DefTableKey));
extern DefTableKey KeyForStructOrUnion ELI_ARG((DefTableKey, TypeKinds));

#endif
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s9.2.2"><H3>9.2.2  buildtype.c</H3></A>

<BLOCKQUOTE>
<A NAME="m241"><B>buildtype.c</B>[241]</A>==<BLOCKQUOTE><PRE>
#include &quot;oiladt2.h&quot;
#include &quot;OilDecls.h&quot;
#include &quot;buildtype.h&quot;

/*
 * This routine finds a qualified version of the current type
 *  The qualifier is specified by a Kwd_(const/volatile) parameter
 *
 * If there is an error, this routine calls the message()  function
 */

DefTableKey 
#ifdef PROTO_OK
KeyForQualifier(DefTableKey currentKey, int isconst, int isvolatile)
#else
KeyForQualifier(currentKey, isconst, isvolatile)
DefTableKey currentKey; int isconst, isvolatile;
#endif
{ DefTableKey UnqualifiedKey, nextKey;

  UnqualifiedKey = GetUnqualifiedType(currentKey,currentKey);

  isconst    |= GetisConst(currentKey,0);
  isvolatile |= GetisVolatile(currentKey,0);

  if (isconst &amp;&amp; isvolatile) {
    if ((nextKey = GetConstVolatileType(UnqualifiedKey,NoKey)) == NoKey) {
      ResetConstVolatileType(UnqualifiedKey, nextKey = NewKey());
      ResetOilType(nextKey, GetOilType(UnqualifiedKey, OilErrorType()));
      ResetisConst(nextKey, 1);
      ResetisVolatile(nextKey, 1);
      ResetUnqualifiedType(nextKey,UnqualifiedKey);
    }
  } else if (isconst) {
    if ((nextKey = GetConstType(UnqualifiedKey,NoKey)) == NoKey) {
      ResetConstType(UnqualifiedKey, nextKey = NewKey());
      ResetOilType(nextKey, GetOilType(UnqualifiedKey, OilErrorType()));
      ResetisConst(nextKey, 1);
      ResetUnqualifiedType(nextKey,UnqualifiedKey);
    }
  } else if (isvolatile) {
    if ((nextKey = GetVolatileType(UnqualifiedKey,NoKey)) == NoKey) {
      ResetVolatileType(UnqualifiedKey, nextKey = NewKey());
      ResetOilType(nextKey, GetOilType(UnqualifiedKey, OilErrorType()));
      ResetisVolatile(nextKey, 1);
      ResetUnqualifiedType(nextKey,UnqualifiedKey);
    }
  } else nextKey = UnqualifiedKey;   /* no qualifiers */
  return nextKey;
}

DefTableKey 
#ifdef PROTO_OK
KeyForPointer(DefTableKey T)
#else
KeyForPointer(T) DefTableKey T;
#endif
{ DefTableKey  PtrKey;

<A HREF="#m236"><I>Pointer type</I>[236]</A>

  return PtrKey;
}

DefTableKey
#ifdef PROTO_OK
KeyForArray(DefTableKey T)
#else
KeyForArray(T) DefTableKey T;
#endif
{ DefTableKey ArrayKey;

<A HREF="#m229"><I>Array type</I>[229]</A>

  return ArrayKey;
}

DefTableKey
#ifdef PROTO_OK
KeyForFunction(DefTableKey T)
#else
KeyForFunction(T) DefTableKey T;
#endif
{ DefTableKey FunctionKey;

<A HREF="#m231"><I>Function type</I>[231]</A>

  return FunctionKey;
}

DefTableKey 
#ifdef PROTO_OK
KeyForStructOrUnion(DefTableKey TagKey, TypeKinds kind)
#else
KeyForStructOrUnion(TagKey, kind) DefTableKey TagKey; TypeKinds kind;
#endif
{ DefTableKey StructTypeKey;

  /* if a key for type is not present for this tag, create one */
  StructTypeKey = GetType(TagKey, NoKey);
  if (StructTypeKey == NoKey) {
    StructTypeKey = NewKey();

    /* reset the type property of the tag */
    ResetType(TagKey, StructTypeKey);

    /* reset the OIL type for the struct or union */
    ResetOilType(
      StructTypeKey,
      OilClassInst0(OilClassTypeIs_Struct,StructTypeKey));
  }

  IsKind(StructTypeKey, kind, Kind_error);
  return StructTypeKey;
}


/*
** This function returns a new DefTableKey for an enum.  All the
** corresponding properties are set for the returned key.
*/

/*
Section 6.5.3 states that all enumeration constants have the type int.
Thus, although every enum is a new type, all enums have an int OIL 
type.
*/

DefTableKey
#ifdef PROTO_OK
KeyForEnum(DefTableKey TagKey)
#else
KeyForEnum(TagKey) DefTableKey TagKey;
#endif
{ DefTableKey EnumTypeKey;

  /* if a key for type is not present for this tag, create one */
  EnumTypeKey = GetType(TagKey, NoKey);
  if (EnumTypeKey == NoKey) {
    EnumTypeKey = NewKey();

    ResetType(TagKey, EnumTypeKey);
    ResetisComplete(EnumTypeKey, 1);

    /* add the new oil type for the enum */
    ResetOilType(EnumTypeKey, OilClassInst0(OilClassTypeIs_Enum, EnumTypeKey));
  }

  /* Check the kind of type, if there is no Kind property
     then the property is set to Kind_enum.  If it's not 
     Kind_enum, change the type to Kind_error */
  IsKind(EnumTypeKey, Kind_enum, Kind_error);

  return EnumTypeKey;
}
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s9.2.3"><H3>9.2.3  buildtype.HEAD.phi</H3></A>

<BLOCKQUOTE>
<A NAME="m242"><B>buildtype.HEAD.phi</B>[242]</A>==<BLOCKQUOTE><PRE>
#include &quot;buildtype.h&quot;
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s9.2.4"><H3>9.2.4  TypeRep.lido</H3></A>

<BLOCKQUOTE>
<A NAME="m243"><B>TypeRep.lido</B>[243]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m233"><I>Attributes for type computations</I>[233]</A>
<A HREF="#m234"><I>Parameter signature computations</I>[234]</A>
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s9.2.5"><H3>9.2.5  TypeRep.pdl</H3></A>

<BLOCKQUOTE>
<A NAME="m244"><B>TypeRep.pdl</B>[244]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m227"><I>Properties of types</I>[227]</A>
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s9.2.6"><H3>9.2.6  TypeRep.specs</H3></A>

<BLOCKQUOTE>
<A NAME="m245"><B>TypeRep.specs</B>[245]</A>==<BLOCKQUOTE><PRE>
$/pdl/keyarray.specs
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>

<A NAME="s10"><H1>10  Type Analysis</H1></A>

As discussed earlier, each type is represented by a definition table key.
These keys are created in textual order, controlled by the chain
<TT>_C_GotTypes</TT>.
<TT>_C_GotTypes</TT> is an assertion that definition table keys are available
for all types introduced to the left of the current textual position.
(Some of these types may be incomplete, but their definition table keys
have been assigned.)
In addition, the void attribute <TT>file.GotAllTypes</TT> indicates that all
type information has been extracted from the program's declarations:
<BLOCKQUOTE>
<A NAME="m246"><I>Chain that indicates types have been set</I>[246]</A>==<BLOCKQUOTE><PRE>
CHAIN _C_GotTypes: VOID;

SYMBOL file COMPUTE
  CHAINSTART HEAD._C_GotTypes=0;
  SYNT.GotAllTypes=TAIL._C_GotTypes DEPENDS_ON THIS.MemberGotScopeProp;
END;

SYMBOL declarator COMPUTE
  THIS.Type=TAIL.TypeChain;
  THIS._C_GotTypes=THIS.Type;
END;

SYMBOL member_declarator COMPUTE
  THIS._C_GotTypes=TAIL.TypeChain;
END;

RULE: member_declarator ::=
COMPUTE
  member_declarator._C_GotTypes=member_declarator._C_GotTypes;
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m272">272</A>.
</BLOCKQUOTE>


<A NAME="s10.1"><H2>10.1  Declarations</H2></A>

<A NAME="s10.1.1"><H3>10.1.1  Storage-class specifiers</H3></A>

<BLOCKQUOTE>
<A NAME="m247"><I>Declaration specifiers</I>[247]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m262"><I>Simple declaration specifier</I>[262]</A> (`typedef')
<A HREF="#m262"><I>Simple declaration specifier</I>[262]</A> (`extern')
<A HREF="#m262"><I>Simple declaration specifier</I>[262]</A> (`static')
<A HREF="#m262"><I>Simple declaration specifier</I>[262]</A> (`auto')
<A HREF="#m262"><I>Simple declaration specifier</I>[262]</A> (`register')
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m247">247</A>, <A HREF="#m250">250</A>, <A HREF="#m254">254</A>, <A HREF="#m260">260</A>, <A HREF="#m261">261</A>, and <A HREF="#m265">265</A>.<BR>
This macro is invoked in definition <A HREF="#m272">272</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m248"><I>Storage-class specifier keywords</I>[248]</A>==<BLOCKQUOTE><PRE>
KWD(Kwd_typedef,  0, (ClassBits)),
KWD(Kwd_extern,   0, (ClassBits)),
KWD(Kwd_static,   0, (ClassBits)),
KWD(Kwd_auto,     0, (ClassBits)),
KWD(Kwd_register, 0, (ClassBits))
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m256">256</A>.
</BLOCKQUOTE>


The <TT>KWD</TT> macro is used simply as a documentation aid, allowing us to
pull together several aspects of the declaration specifiers.
The first argument is the enumerated constant used to represent the
declaration specifier internally, and the third gives the set of
declaration specifiers that are incompatible with the specifier
represented by the keyword.
Abbreviations are used for specific groups of bits:
<BLOCKQUOTE>
<A NAME="m249"><I>Abbreviations for sets of bits</I>[249]</A>==<BLOCKQUOTE><PRE>
#define ClassBits ((1&lt;&lt;(Kwd_register + 1)) - (1&lt;&lt;Kwd_typedef))
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m249">249</A> and <A HREF="#m251">251</A>.<BR>
This macro is invoked in definition <A HREF="#m269">269</A>.
</BLOCKQUOTE>


This ensures that at most one storage-class specifier may be given in the
declaration specifiers of a declaration.
<A NAME="s10.1.2"><H3>10.1.2  Type specifiers</H3></A>

<BLOCKQUOTE>
<A NAME="m250"><I>Declaration specifiers</I>[250]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m263"><I>Specifier that determines type</I>[263]</A> (`void', `TypeIs_void')
<A HREF="#m262"><I>Simple declaration specifier</I>[262]</A> (`char')
<A HREF="#m262"><I>Simple declaration specifier</I>[262]</A> (`short')
<A HREF="#m262"><I>Simple declaration specifier</I>[262]</A> (`int')
<A HREF="#m262"><I>Simple declaration specifier</I>[262]</A> (`long')
<A HREF="#m263"><I>Specifier that determines type</I>[263]</A> (`float', `TypeIs_float')
<A HREF="#m262"><I>Simple declaration specifier</I>[262]</A> (`double')
<A HREF="#m262"><I>Simple declaration specifier</I>[262]</A> (`signed')
<A HREF="#m262"><I>Simple declaration specifier</I>[262]</A> (`unsigned')
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m247">247</A>, <A HREF="#m250">250</A>, <A HREF="#m254">254</A>, <A HREF="#m260">260</A>, <A HREF="#m261">261</A>, and <A HREF="#m265">265</A>.<BR>
This macro is invoked in definition <A HREF="#m272">272</A>.
</BLOCKQUOTE>


As in the case of storage specifiers, the <TT>KWD</TT> macro is used to describe
the keywords and the constraints on their use.
The abbreviations are:
<BLOCKQUOTE>
<A NAME="m251"><I>Abbreviations for sets of bits</I>[251]</A>==<BLOCKQUOTE><PRE>
#define TypeBits ((1&lt;&lt;Kwd_char) | (1&lt;&lt;Kwd_int) | (1&lt;&lt;Kwd_double))
#define SizeBits ((1&lt;&lt;Kwd_short) | (1&lt;&lt;Kwd_long))
#define SignBits ((1&lt;&lt;Kwd_signed) | (1&lt;&lt;Kwd_unsigned))
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m249">249</A> and <A HREF="#m251">251</A>.<BR>
This macro is invoked in definition <A HREF="#m269">269</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m252"><I>Type specifier keywords</I>[252]</A>==<BLOCKQUOTE><PRE>
/*      void    is represented by Kwd_typeid  */
KWD(Kwd_char,     1, ((1&lt;&lt;Kwd_typeid) | TypeBits | SizeBits)),
KWD(Kwd_short,    3, ((1&lt;&lt;Kwd_typeid) | SizeBits | (1&lt;&lt;Kwd_char))),
KWD(Kwd_int,      0, ((1&lt;&lt;Kwd_typeid) | TypeBits)),
KWD(Kwd_long,     4, ((1&lt;&lt;Kwd_typeid) | SizeBits | (1&lt;&lt;Kwd_char))),
/*      float   is represented by Kwd_typeid */
KWD(Kwd_double,   2, ((1&lt;&lt;Kwd_typeid) | TypeBits | (1&lt;&lt;Kwd_short) | SignBits)),
KWD(Kwd_signed,   5, ((1&lt;&lt;Kwd_typeid) | SignBits)),
KWD(Kwd_unsigned, 6, ((1&lt;&lt;Kwd_typeid) | SignBits)),
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m252">252</A> and <A HREF="#m253">253</A>.<BR>
This macro is invoked in definition <A HREF="#m256">256</A>.
</BLOCKQUOTE>


A <TT>struct_or_union_specifier</TT>, <TT>enum_specifier</TT> or <TT>typedef_name</TT> is
represented by the keyword <TT>Kwd_typeid</TT>.
Like <TT>void</TT> and <TT>float</TT>, these specifiers completely determine the type
and may not occur with any other type specifiers:
<BLOCKQUOTE>
<A NAME="m253"><I>Type specifier keywords</I>[253]</A>==<BLOCKQUOTE><PRE>
KWD(Kwd_typeid,   0, ((1&lt;&lt;Kwd_typeid) - (1&lt;&lt;Kwd_char)))
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m252">252</A> and <A HREF="#m253">253</A>.<BR>
This macro is invoked in definition <A HREF="#m256">256</A>.
</BLOCKQUOTE>


In general, all of the specifiers must be examined before the specified
type is known.
We use a chain, <TT>Specification</TT>,
to implement the state of the specifier scan:
<BLOCKQUOTE>
<A NAME="m254"><I>Declaration specifiers</I>[254]</A>==<BLOCKQUOTE><PRE>
CHAIN Specification: SpecData;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m247">247</A>, <A HREF="#m250">250</A>, <A HREF="#m254">254</A>, <A HREF="#m260">260</A>, <A HREF="#m261">261</A>, and <A HREF="#m265">265</A>.<BR>
This macro is invoked in definition <A HREF="#m272">272</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m255"><I>Specification data</I>[255]</A>==<BLOCKQUOTE><PRE>
typedef struct {
  long KeywordSet;
  DefTableKey SpecifiedType;
  int CurrentState;
} SpecData;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m274">274</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m256"><I>Specifier keywords</I>[256]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m252"><I>Type specifier keywords</I>[252]</A>,
<A HREF="#m248"><I>Storage-class specifier keywords</I>[248]</A>,
KWD(Kwd_const,    0, ((1&lt;&lt;Kwd_const) | (1&lt;&lt;Kwd_volatile))),
KWD(Kwd_volatile, 0, ((1&lt;&lt;Kwd_const) | (1&lt;&lt;Kwd_volatile)))
</PRE></BLOCKQUOTE>
This macro is invoked in definitions <A HREF="#m259">259</A> and <A HREF="#m269">269</A>.
</BLOCKQUOTE>


The <TT>KWD</TT> macro is used simply as a documentation aid, allowing us to
pull together several aspects of the declaration specifiers.
The first argument is the enumerated constant used to represent the
declaration specifier internally.
The second argument is that specifier's input value for the finite state
machine that ultimately determines the type represented by the sequence of
specifiers.
Finally, the third argument gives the set of declaration specifiers that
are incompatible with the specifier represented by the keyword.
Abbreviations, defined as follows, are used for specific groups of bits:
<P>
The finite-state machine is defined by the following transition table:
<BLOCKQUOTE>
<A NAME="m257"><I>Finite-state machine</I>[257]</A>==<BLOCKQUOTE><PRE>
/*                          u
 *                          n
 *              d        s  s
 *              o  s     i  i
 *           c  u  h  l  g  g
 *        i  h  b  o  o  n  n
 *        n  a  l  r  n  e  e
 *        t  r  e  t  g  d  d
 ***/
/* 0*/ {{ 0, 1, 9, 4, 7, 0, 6}, TypeIs_int},
/* 1*/ {{ 1, 1, 1, 1, 1, 2, 3}, TypeIs_char},
/* 2*/ {{ 2, 2, 2, 2, 2, 2, 2}, TypeIs_signed_char},
/* 3*/ {{ 3, 3, 3, 3, 3, 3, 3}, TypeIs_unsigned_char},
/* 4*/ {{ 4, 4, 4, 4, 4, 4, 5}, TypeIs_short},
/* 5*/ {{ 5, 5, 5, 5, 5, 5, 5}, TypeIs_unsigned_short},
/* 6*/ {{ 6, 3, 6, 5, 8, 6, 6}, TypeIs_unsigned_int},
/* 7*/ {{ 7, 7, 7, 7, 7, 7, 8}, TypeIs_long},
/* 8*/ {{ 8, 8, 8, 8, 8, 8, 8}, TypeIs_unsigned_long},
/* 9*/ {{ 9, 9, 9, 9,10, 9, 9}, TypeIs_double},
/*10*/ {{10,10,10,10,10,10,10}, TypeIs_long_double}
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m277">277</A>.
</BLOCKQUOTE>


State 0 is the initial state, and if the state of the machine determines
the type, the type determined is specified by the second component of the
state.
<P>
The finite-state machine is implemented as part of an abstract data type
that exports the operations <TT>InitSpecifiers</TT>, <TT>FinalType</TT> and
<TT>InSpecifierSet</TT> to its customers.
<BLOCKQUOTE>
<A NAME="m258"><I>Abstract data type for finite-state machine</I>[258]</A>==<BLOCKQUOTE><PRE>
SpecData
#ifdef PROTO_OK
InitSpecifiers(void)
#else
InitSpecifiers()
#endif
{ SpecData CurrentData;
  CurrentData.KeywordSet    = 0;
  CurrentData.SpecifiedType = NoKey;
  CurrentData.CurrentState  = 0;
  return CurrentData; }

DefTableKey
#ifdef PROTO_OK
FinalType(SpecData chain)
#else
FinalType(chain) SpecData chain;
#endif
{ if (chain.SpecifiedType != NoKey) return chain.SpecifiedType;
  else return State[chain.CurrentState].Type;
}
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m258">258</A> and <A HREF="#m259">259</A>.<BR>
This macro is invoked in definition <A HREF="#m277">277</A>.
</BLOCKQUOTE>


Another operation, <TT>NextSpecifier</TT>, is exported by the module.
This operation takes the keyword for the specifier and the chain value.
It returns <TT>1</TT> if the specifier is legal in the current state of the
machine, and <TT>0</TT> otherwise.
It also caches the updated chain value for subsequent operations.
<BLOCKQUOTE>
<A NAME="m259"><I>Abstract data type for finite-state machine</I>[259]</A>==<BLOCKQUOTE><PRE>
#define KWD(w,i,s) i
static int FSMInput[] = {
<A HREF="#m256"><I>Specifier keywords</I>[256]</A>
};
#undef KWD

#define KWD(w,i,s) s
static long Exclude[] = {
<A HREF="#m256"><I>Specifier keywords</I>[256]</A>
};
#undef KWD

int
#ifdef PROTO_OK
NextSpecifier(TypeSpecifier kw, SpecData chain)
#else
NextSpecifier(kw, chain) TypeSpecifier kw; SpecData chain;
#endif
{ return (Exclude[kw] &amp; chain.KeywordSet) == 0; }

SpecData
#ifdef PROTO_OK
UpdateSpecification(DefTableKey type, TypeSpecifier kw, SpecData chain)
#else
UpdateSpecification(type, kw, chain)
DefTableKey type; TypeSpecifier kw; SpecData chain;
#endif
{ if ((Exclude[kw] &amp; chain.KeywordSet) == 0) {
    if (type != NoKey) chain.SpecifiedType = type;
    chain.KeywordSet |= (1 &lt;&lt; kw);
    chain.CurrentState = State[chain.CurrentState].Next[FSMInput[kw]];
  }
  return chain;
}
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m258">258</A> and <A HREF="#m259">259</A>.<BR>
This macro is invoked in definition <A HREF="#m277">277</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m260"><I>Declaration specifiers</I>[260]</A>==<BLOCKQUOTE><PRE>
SYMBOL declaration_specifiers COMPUTE
  CHAINSTART HEAD.Specification=InitSpecifiers() DEPENDS_ON THIS._C_GotTypes;
  SYNT.TypeSpecified=FinalType(TAIL.Specification);
  SYNT.IsTypedef= InSpecifierSet(Kwd_typedef, TAIL.Specification);
  SYNT.IsExtern=  InSpecifierSet(Kwd_extern,  TAIL.Specification);
  SYNT.IsStatic=  InSpecifierSet(Kwd_static,  TAIL.Specification);
  SYNT.IsRegister=InSpecifierSet(Kwd_register,TAIL.Specification);
  SYNT.IsConst=   InSpecifierSet(Kwd_const,   TAIL.Specification);
  SYNT.IsVolatile=InSpecifierSet(Kwd_volatile,TAIL.Specification);
  THIS._C_GotTypes=&quot;yes&quot;
    DEPENDS_ON (
      THIS.TypeSpecified,
      THIS.IsTypedef,
      THIS.IsExtern,
      THIS.IsStatic,
      THIS.IsRegister,
      THIS.IsConst,
      THIS.IsVolatile);
END;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m247">247</A>, <A HREF="#m250">250</A>, <A HREF="#m254">254</A>, <A HREF="#m260">260</A>, <A HREF="#m261">261</A>, and <A HREF="#m265">265</A>.<BR>
This macro is invoked in definition <A HREF="#m272">272</A>.
</BLOCKQUOTE>


<TT>NextSpecifier</TT> is used to set the attribute <TT>ok</TT> which, in turn,
controls the production of an error report:
<BLOCKQUOTE>
<A NAME="m261"><I>Declaration specifiers</I>[261]</A>==<BLOCKQUOTE><PRE>
ATTR ok: int;

SYMBOL declaration_specifier COMPUTE
  IF(NOT(THIS.ok),
    message(ERROR,&quot;Illegal specifier&quot;,0,COORDREF));
END;
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m247">247</A>, <A HREF="#m250">250</A>, <A HREF="#m254">254</A>, <A HREF="#m260">260</A>, <A HREF="#m261">261</A>, and <A HREF="#m265">265</A>.<BR>
This macro is invoked in definition <A HREF="#m272">272</A>.
</BLOCKQUOTE>


The computation of <TT>ok</TT> is the only task to be done for most of the
declaration specifiers, but these computations must be synchronized via
<TT>Specification</TT>:
<BLOCKQUOTE>
<A NAME="m262"><I>Simple declaration specifier</I>[262]</A>(&#182;1)==<BLOCKQUOTE><PRE>
RULE: declaration_specifier ::= '&#182;1'
COMPUTE
  declaration_specifier.ok=
    NextSpecifier(Kwd_&#182;1,declaration_specifier.Specification);
  declaration_specifier.Specification=
    UpdateSpecification(NoKey,Kwd_&#182;1,declaration_specifier.Specification);
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definitions <A HREF="#m247">247</A>, <A HREF="#m250">250</A>, and <A HREF="#m265">265</A>.
</BLOCKQUOTE>


Here the parameter is the C keyword.
<P>
Five type specifiers determine the type immediately, and cannot appear
with size or sign specifiers.
<BLOCKQUOTE>
<A NAME="m263"><I>Specifier that determines type</I>[263]</A>(&#182;2)==<BLOCKQUOTE><PRE>
RULE: declaration_specifier ::= '&#182;1'
COMPUTE
  declaration_specifier.ok=
    NextSpecifier(Kwd_typeid,declaration_specifier.Specification);
  declaration_specifier.Specification=
    UpdateSpecification(&#182;2,Kwd_typeid,declaration_specifier.Specification);
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m250">250</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m264"><I>type for ds1 with a typedef_name</I>[264]</A>==<BLOCKQUOTE><PRE>
RULE: declaration_specifier ::= typedef_name
COMPUTE
  declaration_specifier.ok=
    NextSpecifier(Kwd_typeid,declaration_specifier.Specification);
  declaration_specifier.Specification=
    UpdateSpecification(
      GetType(OrdinaryIdStackArray(typedef_name), NoKey),
      Kwd_typeid,
      declaration_specifier.Specification);
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m272">272</A>.
</BLOCKQUOTE>


<A NAME="s10.1.3"><H3>10.1.3  Type Qualifiers</H3></A>

<BLOCKQUOTE>
<A NAME="m265"><I>Declaration specifiers</I>[265]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m262"><I>Simple declaration specifier</I>[262]</A> (`const')
<A HREF="#m262"><I>Simple declaration specifier</I>[262]</A> (`volatile')
</PRE></BLOCKQUOTE>
This macro is defined in definitions <A HREF="#m247">247</A>, <A HREF="#m250">250</A>, <A HREF="#m254">254</A>, <A HREF="#m260">260</A>, <A HREF="#m261">261</A>, and <A HREF="#m265">265</A>.<BR>
This macro is invoked in definition <A HREF="#m272">272</A>.
</BLOCKQUOTE>


Since incompleteness of a type depends on processing the types 
in textual order, we need to ensure this order is maintained 
during the evaluation of the types by using the <TT>_C_GotTypes</TT> chain.
<P>
If a <TT>struct_or_union_specifier</TT> contains a member specification,
the computations create a new type in accordance to the standard
section 6.5.2.3.  The new type is a struct or union containing 
the members of <TT>component_list</TT>.  The list of members is created
by consistent renaming over member scopes and is available in
<TT>component_list.MemberEnv</TT>.
<BLOCKQUOTE>
<A NAME="m266"><I>type for ds1 with a struct_or_union_specifier</I>[266]</A>==<BLOCKQUOTE><PRE>
RULE: declaration_specifier ::= struct_or_union_specifier
COMPUTE
  declaration_specifier.ok=
    NextSpecifier(Kwd_typeid,struct_or_union_specifier.Specification);
  declaration_specifier.Specification=
    UpdateSpecification(
      struct_or_union_specifier.Type,
      Kwd_typeid,
      struct_or_union_specifier.Specification);
END;

ATTR IsStruct: TypeKinds;

RULE: struct_or_union ::= 'struct'
COMPUTE
  struct_or_union.IsStruct=Kind_struct;
END;

RULE: struct_or_union ::= 'union'
COMPUTE
  struct_or_union.IsStruct=Kind_union;
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m272">272</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m267"><I>type for ds1 with a enum_specifier</I>[267]</A>==<BLOCKQUOTE><PRE>
RULE: declaration_specifier ::= enum_specifier
COMPUTE
  declaration_specifier.ok=
    NextSpecifier(Kwd_typeid,declaration_specifier.Specification);
  declaration_specifier.Specification=
    UpdateSpecification(
      enum_specifier.Type,
      Kwd_typeid,
      declaration_specifier.Specification)
    DEPENDS_ON enum_specifier.Specification;
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m272">272</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m268"><I>Type kinds</I>[268]</A>==<BLOCKQUOTE><PRE>
typedef enum {
  Kind_error,
  Kind_struct,
  Kind_union,
  Kind_enum,
  Kind_function,
} TypeKinds;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m274">274</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m269"><I>Type keywords</I>[269]</A>==<BLOCKQUOTE><PRE>
#define KWD(w,i,s) w
typedef enum {
<A HREF="#m256"><I>Specifier keywords</I>[256]</A>
} TypeSpecifier;
#undef KWD

<A HREF="#m249"><I>Abbreviations for sets of bits</I>[249]</A>
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m274">274</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m270"><I>typesets code</I>[270]</A>==<BLOCKQUOTE><PRE>
TypeIs_void             -&gt; PointedToBy={TypeIs_VoidPointer};
TypeIs_VoidPointer      -&gt; BaseType={TypeIs_void};
  
/* void is incomplete according to the standard */
TypeIs_char             -&gt; isComplete={1};
TypeIs_signed_char      -&gt; isComplete={1};
TypeIs_unsigned_char    -&gt; isComplete={1};
TypeIs_short            -&gt; isComplete={1};
TypeIs_unsigned_short   -&gt; isComplete={1};
TypeIs_int              -&gt; isComplete={1};
TypeIs_unsigned_int     -&gt; isComplete={1};
TypeIs_long             -&gt; isComplete={1};
TypeIs_unsigned_long    -&gt; isComplete={1};
TypeIs_float            -&gt; isComplete={1};
TypeIs_double           -&gt; isComplete={1};
TypeIs_long_double      -&gt; isComplete={1};
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m273">273</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m271"><I>Set library</I>[271]</A>==<BLOCKQUOTE><PRE>
$/Adt/IntSet.gnrc :inst
$/Adt/List.gnrc+instance=DefTableKey +referto=deftbl :inst
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m275">275</A>.
</BLOCKQUOTE>


<A NAME="s10.2"><H2>10.2  Specification Files</H2></A>

<A NAME="s10.2.1"><H3>10.2.1  type.lido</H3></A>

<BLOCKQUOTE>
<A NAME="m272"><B>type.lido</B>[272]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m246"><I>Chain that indicates types have been set</I>[246]</A>
<A HREF="#m247"><I>Declaration specifiers</I>[247]</A>
<A HREF="#m264"><I>type for ds1 with a typedef_name</I>[264]</A>
<A HREF="#m266"><I>type for ds1 with a struct_or_union_specifier</I>[266]</A>
<A HREF="#m267"><I>type for ds1 with a enum_specifier</I>[267]</A>
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s10.2.2"><H3>10.2.2  type.pdl</H3></A>

<BLOCKQUOTE>
<A NAME="m273"><B>type.pdl</B>[273]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m270"><I>typesets code</I>[270]</A>
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s10.2.3"><H3>10.2.3  type.h</H3></A>

<BLOCKQUOTE>
<A NAME="m274"><B>type.h</B>[274]</A>==<BLOCKQUOTE><PRE>
#ifndef TYPE_H
#define TYPE_H

#include &quot;eliproto.h&quot;
#include &quot;deftbl.h&quot;
#include &quot;envmod.h&quot;

#define UNSIZEDARRAY (0)

struct ArrayTuple
{
        DefTableKey TheKey;
        int     Size;
        struct ArrayTuple *Next;
};

typedef struct ArrayTuple *ArrayList;
#define NoArrayList ((ArrayList) 0)

extern void AddToArrayList ELI_ARG((ArrayList *, DefTableKey, int));
extern DefTableKey FindArraySized ELI_ARG((ArrayList, int));

<A HREF="#m268"><I>Type kinds</I>[268]</A>
<A HREF="#m269"><I>Type keywords</I>[269]</A>

<A HREF="#m255"><I>Specification data</I>[255]</A>

extern SpecData InitSpecifiers ELI_ARG((void));
extern SpecData
  UpdateSpecification ELI_ARG((DefTableKey, TypeSpecifier, SpecData));
extern DefTableKey FinalType ELI_ARG((SpecData));
extern int NextSpecifier ELI_ARG((TypeSpecifier, SpecData));

#define InSpecifierSet(kw,chain) (((1 &lt;&lt; kw) &amp; chain.KeywordSet) != 0)

#endif
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s10.2.4"><H3>10.2.4  type.specs</H3></A>

<BLOCKQUOTE>
<A NAME="m275"><B>type.specs</B>[275]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m271"><I>Set library</I>[271]</A>
$/oil/oiladt2.h
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s10.2.5"><H3>10.2.5  type.head</H3></A>

<BLOCKQUOTE>
<A NAME="m276"><B>type.head</B>[276]</A>==<BLOCKQUOTE><PRE>
#include &quot;type.h&quot;
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s10.2.6"><H3>10.2.6  type.c</H3></A>

<BLOCKQUOTE>
<A NAME="m277"><B>type.c</B>[277]</A>==<BLOCKQUOTE><PRE>
#include &quot;type.h&quot;
#include &quot;oiladt2.h&quot;
#include &quot;OilDecls.h&quot;
#include &quot;buildtype.h&quot;

static struct {int Next[7]; DefTableKey Type;} State[] = {
<A HREF="#m257"><I>Finite-state machine</I>[257]</A>
};

<A HREF="#m258"><I>Abstract data type for finite-state machine</I>[258]</A>
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>
 
<A NAME="s11"><H1>11  Tree Type Computations</H1></A>

This section is for all tree computations of expressions.
<A NAME="s11.1"><H2>11.1  Type computations in expressions</H2></A>

This section of the document does the type computations for
expressions, to determine the needed types, type coercions,
constant value calculations, etc.
<A NAME="s11.1.1"><H3>11.1.1  Calculate possible and final types</H3></A>

The following computations do type calculations for expressions,
to determine the operators that are needed.  Note that
According to section 6.4 of the standard, "Constant expressions 
shall not contain assignment, increment, decrement, function-call,
or comma operators, except when they are contained within the
operand of a sizeof operator."  This is why comma expressions are
never treated as constant expressions.
<BLOCKQUOTE>
<A NAME="m278"><I>Rule computations</I>[278]</A>==<BLOCKQUOTE><PRE>
ATTR op           : tOilOp;       /* attributes only used locally */

ATTR PossTypes    : tOilTypeSet;  /* possible types.  A synthesized attribute */
ATTR FinalType    : tOilType;     /* final type.  an inherited attribute      */
ATTR Indication   : tOilOp;

ATTR ExprValue    : int;

SYMBOL Expression:
  IsKnownConst : int,
  NeedaFunc    : int;          /* true for function calls */

SYMBOL file COMPUTE
  SYNT.GotAllConstantId=CONSTITUENTS enumeration_constant.GotConstantId;
END;

SYMBOL enumeration_constant COMPUTE
  SYNT.GotConstantId=ResetIsKnownConst(THIS.Key, 1);
END;

SYMBOL Expression COMPUTE
  SYNT.IsKnownConst=0;
  SYNT.ExprValue=0;
  INH.NeedaFunc=0;
  INH.FinalType=OilSelectTypeFromTS(THIS.PossTypes);
END;

RULE: constant_exp_opt ::= 
COMPUTE
  constant_exp_opt.ExprValue = 0;
END;

RULE: Expression ::= IdUse
COMPUTE
  Expression.PossTypes=
    IF (EQ(Expression.NeedaFunc, 1),
      GetTypeWhenIdUseIsaFunction(IdUse.Key, COORDREF),
      GetTypeWhenIdUseIsDefined(IdUse.Key, COORDREF))
    DEPENDS_ON INCLUDING file.GotAllTypes;
  Expression.IsKnownConst=
    GetIsKnownConst(IdUse.Key, 0)
    DEPENDS_ON INCLUDING file.GotAllConstantId;
END;

RULE: Expression ::= constant
COMPUTE
  Expression.PossTypes = constant.PossTypes;
  Expression.ExprValue = constant.ExprValue;
  Expression.IsKnownConst = 1;
END;

RULE: Expression ::= StringSeq
COMPUTE
  Expression.PossTypes=
    OilTypeToSet(
      GetOilType(
        KeyForQualifier(KeyForPointer(TypeIs_char), 1, 0),
        OilErrorType()));
  Expression.IsKnownConst = 1;
END;

RULE: Expression ::= Expression '[' Expression ']'
COMPUTE
  .op=
    OilIdOpTS2(
      Expression[1].FinalType,
      OilOpSubscript_Indication,
      Expression[2].PossTypes,
      Expression[3].PossTypes);
  Expression[1].PossTypes=
    OilIdResultTS2(
      OilOpSubscript_Indication,
      Expression[2].PossTypes,
      Expression[3].PossTypes);
  Expression[1].IsKnownConst=
    AND(Expression[2].IsKnownConst,Expression[3].IsKnownConst);
  Expression[2].FinalType=OilGetArgType(.op,1);
  Expression[3].FinalType=OilGetArgType(.op,2);
END;

RULE: Expression ::= Expression '(' argument_exp_list ')'
COMPUTE
  .op=
    OilIdOpTS1(
      Expression[1].FinalType,
      OilOpCall_Indication,
      Expression[2].PossTypes);
IF(NOT(OilIsValidOp(.op)),message(ERROR,&quot;Invalid call&quot;,0,COORDREF));
  /* check arg list types */
  Expression[1].PossTypes=
    OilIdResultTS1(OilOpCall_Indication, Expression[2].PossTypes);
  Expression[2].NeedaFunc=1;
END;

RULE: Expression ::= Expression '(' ')'
COMPUTE
  /* check arg list types */
  Expression[1].PossTypes=
    OilIdResultTS1(OilOpCall_Indication, Expression[2].PossTypes);
  Expression[2].NeedaFunc=1;
END;

ATTR type: DefTableKey;
ATTR kind: TypeKinds;

RULE: Expression ::= Expression '.' MemberIdUse
COMPUTE
  .type=OilTypeName(OilSelectTypeFromTS(Expression[2].PossTypes));
  .kind=GetKind(.type,Kind_error);
  Expression[1].PossTypes =
    OilTypeToSet(
      GetOilType(
        GetType(MemberIdUse.MemberKey,NoKey),
        OilErrorType()));
  MemberIdUse.MemberScope=GetMemberScope(.type,NoEnv);
  IF(AND(NE(.kind,Kind_struct),NE(.kind,Kind_union)),
    message(ERROR,&quot;Not a structure or union&quot;,0,COORDREF));
END;

RULE: Expression ::= Expression '-&gt;' MemberIdUse
COMPUTE
  .type=
    GetBaseType(
      OilTypeName(OilSelectTypeFromTS(Expression[2].PossTypes)),
      NoKey);
  .kind=GetKind(.type,Kind_error);
  Expression[1].PossTypes=
    OilTypeToSet(
      GetOilType(
        GetType(MemberIdUse.MemberKey,NoKey),
        OilErrorType()));
  MemberIdUse.MemberScope=GetMemberScope(.type,NoEnv);
  IF(AND(NE(.kind,Kind_struct),NE(.kind,Kind_union)),
    message(ERROR,&quot;Not a pointer to a structure or union&quot;,0,COORDREF));
END;

RULE: Expression ::= Expression '++'
COMPUTE
  .op=
    OilIdOpTS1(
      Expression[1].FinalType,
      OilOpIncrement_Indication,
      Expression[2].PossTypes);
  Expression[1].PossTypes=Expression[2].PossTypes;
  Expression[2].FinalType=OilGetArgType(.op,1);
END;

RULE: Expression ::= Expression '--'
COMPUTE
  .op=
    OilIdOpTS1(
      Expression[1].FinalType,
      OilOpDecrement_Indication,
      Expression[2].PossTypes);
  Expression[1].PossTypes=Expression[2].PossTypes;
  Expression[2].FinalType=OilGetArgType(.op, 1);
END;

RULE: Expression ::= '++' Expression
COMPUTE
  .op=
    OilIdOpTS1(
      Expression[1].FinalType,
      OilOpIncrement_Indication,
      Expression[2].PossTypes);
  Expression[1].PossTypes=Expression[2].PossTypes;
  Expression[2].FinalType=OilGetArgType(.op,1);
END;

RULE: Expression ::= '--' Expression
COMPUTE
  .op=
    OilIdOpTS1(
      Expression[1].FinalType,
      OilOpDecrement_Indication,
      Expression[2].PossTypes);
  Expression[1].PossTypes=Expression[2].PossTypes;
  Expression[2].FinalType=OilGetArgType(.op,1);
END;

RULE: Expression ::= unary_operator Expression
COMPUTE
  .op=unary_operator.op;
  Expression[1].PossTypes=
    OilIdResultTS1(unary_operator.Indication,Expression[2].PossTypes);
  unary_operator.op=
    OilIdOpTS1(
      Expression[1].FinalType,
      unary_operator.Indication,
      Expression[2].PossTypes);
  Expression[1].IsKnownConst=
    IF(
      OR(
        EQ(unary_operator.Indication,OilOpDereference_Indication),
        EQ(unary_operator.Indication,OilOpReference_Indication)),
      0,
      Expression[2].IsKnownConst);
  Expression[2].FinalType=OilGetArgType(unary_operator.op,1);
END;

RULE: Expression ::= 'sizeof' Expression
COMPUTE
  Expression[1].PossTypes=OilTypeToSet(OilTypeTypeIs_int);
  Expression[1].IsKnownConst=1;
END;

RULE: Expression ::= 'sizeof' '(' type_name ')'
COMPUTE
  Expression[1].PossTypes=OilTypeToSet(OilTypeTypeIs_int);
  Expression[1].IsKnownConst=1;
END;

RULE: Expression ::= '(' type_name ')' Expression
COMPUTE
  .op=
    OilIdOpTS1(
      GetOilType(type_name.Type,OilErrorType()),
      OilOpCast_Indication,
      Expression[2].PossTypes);
  Expression[1].PossTypes=
    OilTypeToSet(GetOilType(type_name.Type,OilErrorType()));
  Expression[1].IsKnownConst=Expression[2].IsKnownConst;
  Expression[1].ExprValue=Expression[2].ExprValue;
  Expression[2].FinalType=OilGetArgType(.op,1);
END;

RULE: Expression ::= Expression binary_operator Expression
COMPUTE
  Expression[1].PossTypes=
    OilIdResultTS2(
      binary_operator.Indication,
      Expression[2].PossTypes,
      Expression[3].PossTypes);
  Expression[1].IsKnownConst=
    AND(Expression[2].IsKnownConst,Expression[3].IsKnownConst);
  binary_operator.op=
    OilIdOpTS2(
      Expression[1].FinalType,
      binary_operator.Indication,
      Expression[2].PossTypes,
      Expression[3].PossTypes);
  Expression[2].FinalType=OilGetArgType(binary_operator.op,1);
  Expression[3].FinalType=OilGetArgType(binary_operator.op,2);
END;

RULE: Expression ::= Expression '?' Expression ':' Expression
COMPUTE
  .op=
    OilIdOpTS1(
      OilTypeTypeIs_int,
      OilOpConditional_Indication,
      Expression[2].PossTypes);
  Expression[1].PossTypes=
    OilTypeToSet(OilBalance(Expression[3].PossTypes,Expression[4].PossTypes));
  Expression[1].IsKnownConst=
    AND(
      Expression[2].IsKnownConst,
      AND(Expression[3].IsKnownConst,Expression[4].IsKnownConst));
  Expression[2].FinalType=OilGetArgType(.op,1);
  Expression[3].FinalType=Expression[1].FinalType;
  Expression[4].FinalType=Expression[1].FinalType;
END;

RULE: Expression ::= Expression ',' Expression
COMPUTE
  Expression[1].PossTypes=Expression[3].PossTypes;
  Expression[3].FinalType=Expression[1].FinalType;
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m293">293</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m279"><I>Miscellaneous Types</I>[279]</A>==<BLOCKQUOTE><PRE>
ATTR FloatValue: int;
RULE: constant ::=  floating_constant
COMPUTE
  constant.PossTypes=OilTypeToSet(OilTypeTypeIs_float);
  constant.ExprValue=floating_constant;
END;

ATTR IntegerValue: int;
RULE: constant ::= integer_constant
COMPUTE
  constant.ExprValue=integer_constant;
  constant.PossTypes=
    IF(EQ(integer_constant,0),
      OilTypeToSet(OilTypeTypeIs_NULL),
      OilTypeToSet(OilTypeTypeIs_int));
END;

ATTR CharValue: int;
RULE: constant ::=  character_constant
COMPUTE
  constant.PossTypes=OilTypeToSet(OilTypeTypeIs_char);
  constant.ExprValue=character_constant;
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m293">293</A>.
</BLOCKQUOTE>



This section is the "shut up the compiler" section.
<BLOCKQUOTE>
<A NAME="m280"><I>Shut Up</I>[280]</A>==<BLOCKQUOTE><PRE>
RULE: struct_declarator ::=  member_declarator ':' Expression
COMPUTE
  /* specify that Expression is an integral constant */
  Expression.FinalType = OilTypeTypeIs_int;
END;

RULE: enumerator ::=  enumeration_constant '=' Expression
COMPUTE
  /* specify that Expression is an integral constant */
  Expression.FinalType = OilTypeTypeIs_unsigned_long;
END;

RULE: labeled_statement ::=  'case' Expression ':' statement
COMPUTE
  /* specify that Expression is an integral constant */
  Expression.FinalType = OilTypeTypeIs_int;
END;

RULE: Expression ::=
COMPUTE
  Expression.PossTypes=OilTypeToSet(OilTypeTypeIs_int);
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m293">293</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m281"><I>Required types</I>[281]</A>==<BLOCKQUOTE><PRE>
RULE: selection_statement ::= 'if' '(' Expression ')' statement
COMPUTE
  .op=
    OilIdOpTS1(
      OilTypeTypeIs_int,
      OilOpConditional_Indication,
      Expression.PossTypes);
END;

RULE: selection_statement ::= 'if' '(' Expression ')' statement 
                               'else' statement
COMPUTE
  .op=
    OilIdOpTS1(
      OilTypeTypeIs_int,
      OilOpConditional_Indication,
      Expression.PossTypes);
END;

RULE: selection_statement ::= 'switch' '(' Expression ')' statement
COMPUTE
  .op=
    OilIdOpTS1(
      OilTypeTypeIs_int,
      OilOpConditional_Indication,
      Expression.PossTypes);
END;

RULE: iteration_statement ::= 'while' '(' Expression ')' statement
COMPUTE
  .op=
    OilIdOpTS1(
      OilTypeTypeIs_int,
      OilOpConditional_Indication,
      Expression.PossTypes);
END;

RULE: iteration_statement ::= 'do' statement 'while' '(' Expression ')' ';'
COMPUTE
  .op=
    OilIdOpTS1(
      OilTypeTypeIs_int,
      OilOpConditional_Indication,
      Expression.PossTypes);
END;

RULE: jump_statement ::= 'return' Expression ';'
COMPUTE
  .op=
    OilIdOp2(
      OilOpAssign_Indication,
      GetOilType(
        GetReturnType(INCLUDING function_definition.Type, NoKey),
        OilErrorType()),
      OilSelectTypeFromTS(Expression.PossTypes));
  Expression.FinalType=OilGetArgType(.op, 2);
END;

RULE: for_test ::=  Expression
COMPUTE
  .op=
    OilIdOpTS1(
      OilTypeTypeIs_int,
      OilOpConditional_Indication,
      Expression.PossTypes);
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m293">293</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m282"><I>Get return type of function_definition</I>[282]</A>==<BLOCKQUOTE><PRE>
RULE: function_definition ::=
     declaration_specifiers declarator declaration_list_opt compound_statement
COMPUTE
  function_definition.Type = declarator.TypeChain;
END;

RULE: function_definition ::=
     declarator declaration_list_opt compound_statement
COMPUTE
  function_definition.Type = declarator.TypeChain;
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m293">293</A>.
</BLOCKQUOTE>


<A NAME="s11.1.2"><H3>11.1.2  Calculate Operator Indications</H3></A>

The following macro can be used to specify all of the rules
for the indications.
<BLOCKQUOTE>
<A NAME="m283"><I>Assign Indication</I>[283]</A>(&#182;3)==<BLOCKQUOTE><PRE>
RULE: &#182;1 ::=  &#182;2
COMPUTE
  &#182;1.Indication = OilOp&#182;3_Indication;
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definitions <A HREF="#m284">284</A> and <A HREF="#m285">285</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m284"><I>Unary Indication rules</I>[284]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`unary_operator', `'&amp;'', `Reference')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`unary_operator', `'*'', `Dereference')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`unary_operator', `'+'', `Plus')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`unary_operator', `'-'', `Minus')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`unary_operator', `'~'', `Bitwise_Not')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`unary_operator', `'!'', `Not')
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m293">293</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m285"><I>Binary Indication rules</I>[285]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'*'', `Multiplication')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'/'', `Division')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'%'', `Mod')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'+'', `Addition')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'-'', `Subtraction')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'&lt;&lt;'', `Bit_Shift_Left')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'&gt;&gt;'', `Bit_Shift_Right')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'&lt;'', `LessThan')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'&gt;'', `Greater')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'&lt;='', `LessThan_Equal')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'&gt;='', `Greater_Equal')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'=='', `Equality')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'!='', `Not_Equal')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'&amp;'', `Bitwise_And')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'^'', `Bitwise_XOr')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'|'', `Bitwise_Or')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'&amp;&amp;'', `And')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'||'', `Or')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'='', `Assign')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'*='', `Mult_Eq')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'/='', `Div_Eq')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'%='', `Mod_Eq')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'+='', `Plus_Eq')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'-='', `Minus_Eq')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'&lt;&lt;='', `Bitwise_Shift_Left_Eq')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'&gt;&gt;='', `Bitwise_Shift_Right_Eq')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'&amp;='', `Bitwise_And_Eq')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'^='', `Bitwise_XOr_Eq')
<A HREF="#m283"><I>Assign Indication</I>[283]</A> (`binary_operator', `'|='', `Bitwise_Or_Eq')
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m293">293</A>.
</BLOCKQUOTE>


<A NAME="s11.2"><H2>11.2  Error Checking</H2></A>

The following rules do sanity checks on the above computations,
to check for error conditions.
<BLOCKQUOTE>
<A NAME="m286"><I>Sanity Checks for constant values</I>[286]</A>==<BLOCKQUOTE><PRE>
RULE: constant_exp_opt ::= Expression
COMPUTE
  constant_exp_opt.ExprValue = Expression.ExprValue;
  IF(NOT(Expression.IsKnownConst),
    message(ERROR,&quot;Array bound is not constant&quot;,0,COORDREF));
END;

RULE: struct_declarator ::= member_declarator ':' Expression
COMPUTE
  IF(NOT(Expression.IsKnownConst),
    message(ERROR,&quot;Bitfield size is not constant&quot;,0,COORDREF));
END;

RULE: enumerator ::= enumeration_constant '=' Expression
COMPUTE
  IF(NOT(Expression.IsKnownConst),
    message(ERROR,&quot;Enumeration value is not constant&quot;,0,COORDREF));
END;

RULE: labeled_statement ::= 'case' Expression ':' statement
COMPUTE
  IF(NOT(Expression.IsKnownConst),
    message(ERROR,&quot;case value is not constant&quot;,0,COORDREF));
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m293">293</A>.
</BLOCKQUOTE>


This operator should eliminate some typing, because most of the checks
are very repetitive.
<BLOCKQUOTE>
<A NAME="m287"><I>Operator Check</I>[287]</A>(&#182;2)==<BLOCKQUOTE><PRE>
RULE: &#182;1
COMPUTE
  IF (EQ(.op, OilErrorOp()),
        message(ERROR, &#182;2, 0, COORDREF));
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m288">288</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m288"><I>Sanity checks for expression types</I>[288]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m287"><I>Operator Check</I>[287]</A> (`Expression ::= Expression '[' Expression ']'', `
                    &quot;Not an array type, or invalid subscript&quot;')

<A HREF="#m287"><I>Operator Check</I>[287]</A> (`Expression ::= Expression '++' ', `
                    &quot;Cannot use increment operator on non-scalar types&quot;')

<A HREF="#m287"><I>Operator Check</I>[287]</A> (`Expression ::= Expression '--' ', `
                    &quot;Cannot use decrement operator on non-scalar types&quot;')

<A HREF="#m287"><I>Operator Check</I>[287]</A> (`Expression ::= '++' Expression ', `
                    &quot;Cannot use increment operator on non-scalar types&quot;')

<A HREF="#m287"><I>Operator Check</I>[287]</A> (`Expression ::= '--' Expression ', `
                    &quot;Cannot use decrement operator on non-scalar types&quot;')

SYMBOL operator COMPUTE
  IF(NOT(OilIsValidOp(THIS.op)),
    message(ERROR, &quot;Invalid operator&quot;, 0, COORDREF));
END;

SYMBOL unary_operator INHERITS operator END;
SYMBOL binary_operator INHERITS operator END;

<A HREF="#m287"><I>Operator Check</I>[287]</A> (`Expression ::= '(' type_name ')' Expression ', `
                    &quot;Illegal cast&quot;')

<A HREF="#m287"><I>Operator Check</I>[287]</A> (`Expression ::= Expression '?' Expression ':' Expression ', `
                    &quot;conditional expression not a valid type&quot;')

<A HREF="#m287"><I>Operator Check</I>[287]</A> (`selection_statement ::= 'if' '(' Expression ')' statement ', `
                    &quot;Illegal expression in if condition&quot;')

<A HREF="#m287"><I>Operator Check</I>[287]</A> (`selection_statement ::= 'if' '(' Expression ')'
                     statement 'else' statement ', `
                    &quot;Illegal expression in if condition&quot;')

<A HREF="#m287"><I>Operator Check</I>[287]</A> (`selection_statement ::= 'switch' '(' Expression ')'
                     statement ', ` &quot;Illegal expression in switch condition&quot;')

<A HREF="#m287"><I>Operator Check</I>[287]</A> (`iteration_statement ::= 'while' '(' Expression ')'
                     statement ', ` &quot;Illegal expression in while condition&quot;')

<A HREF="#m287"><I>Operator Check</I>[287]</A> (`iteration_statement ::= 'do' statement 'while'
                    '(' Expression ')' ';' ', `
                     &quot;Illegal expression in while condition&quot;')

<A HREF="#m287"><I>Operator Check</I>[287]</A> (`for_test ::=  Expression ', `
                     &quot;Illegal expression in while condition&quot;')


RULE: Expression ::= Expression '?' Expression ':' Expression
COMPUTE
  IF (EQ(OilSelectTypeFromTS(Expression[1].PossTypes), OilErrorType()),
        message(ERROR,
         &quot;The expressions for ':' have incompatible types&quot;,
         0, COORDREF));
END;
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m293">293</A>.
</BLOCKQUOTE>


<A NAME="s11.2.1"><H3>11.2.1  Code to handle previously undefined variables</H3></A>

The following code is used to do two things: make sure that "normal"
uses of variables are declared before use, and to make sure that when
call are made to funtions that were perviously undeclared, the <TT>DefTableKey</TT>
for that variable is properly set up.  This means guaranteeing that the 
<TT>DefTableKey</TT> has an <TT>OilType</TT>, etc., etc...
<BLOCKQUOTE>
<A NAME="m289"><I>Guarantee DefTableKey for function</I>[289]</A>==<BLOCKQUOTE><PRE>
tOilTypeSet
#ifdef PROTO_OK
GetTypeWhenIdUseIsaFunction(DefTableKey functionKey, CoordPtr curpos)
#else
GetTypeWhenIdUseIsaFunction(functionKey, curpos)
  DefTableKey functionKey;
  CoordPtr curpos;
#endif
{
  /*
   *  Comment: currently, the only context this is being called from is
   *    when we have been handed a DefTableKey (of an identifier), and we 
   *    know that this DefTableKey has to have a function type.
   */

  if (GetType(functionKey, NoKey) == NoKey) {

    /*
     *  If we get to here, this key doesn't have a Type property set.
     *    I take this to mean that this is the 1st time we've seen it,
     *    which means that it gets turned into an incomplete prototype
     */
    ResetType(functionKey, KeyForFunction(TypeIs_int));
    ResetKind(functionKey, Kind_function);
  }

  /*
   *  Make sure that we're working with a function
   */
  if (GetKind( GetType(functionKey, NoKey), Kind_error ) != Kind_function) {
    message(ERROR, &quot;Illegal function&quot;, 0, curpos);
    return OilTypeToSet(OilErrorType());
  }

  return OilTypeToSet(GetOilType(GetType(functionKey,NoKey),OilErrorType()));
}
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m292">292</A>.
</BLOCKQUOTE>


This code makes sure that the given <TT>DefTableKey</TT> has been declared,
and that this is not the 1st occurrence of it.
<BLOCKQUOTE>
<A NAME="m290"><I>Guarantee declaration for DefTableKey</I>[290]</A>==<BLOCKQUOTE><PRE>
tOilTypeSet
#ifdef PROTO_OK
GetTypeWhenIdUseIsDefined (DefTableKey variableKey, CoordPtr curpos)
#else
GetTypeWhenIdUseIsDefined (variableKey, curpos)
  DefTableKey variableKey;
  CoordPtr curpos;
#endif
{ TypeKinds kind;
  DefTableKey IdType;

  if (GetType(variableKey, NoKey) == NoKey) {
    /*
     * This may be wrong.... but it prevents some cascade errors if we
     *   use this variable in other places
     */
    ResetType(variableKey, TypeIs_int);
    ResetReturnType(variableKey, TypeIs_int);
  }

  IdType = GetType(variableKey, NoKey);
  return
    OilTypeToSet(
      GetOilType(
        GetKind(IdType, Kind_error) == Kind_function ?
          GetPointedToBy(IdType, NoKey) :
          IdType,
      OilErrorType()));
}
</PRE></BLOCKQUOTE>
This macro is invoked in definition <A HREF="#m292">292</A>.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m291"><B>defkeyfunc.h</B>[291]</A>==<BLOCKQUOTE><PRE>
#ifndef DEFKEYFUNC_H
#define DEFKEYFUNC_H

#include &quot;eliproto.h&quot;
#include &quot;deftbl.h&quot;
#include &quot;buildtype.h&quot;
#include &quot;envmod.h&quot;

tOilTypeSet GetTypeWhenIdUseIsaFunction ELI_ARG((DefTableKey, CoordPtr));
tOilTypeSet GetTypeWhenIdUseIsDefined ELI_ARG((DefTableKey, CoordPtr));

#endif
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m292"><B>defkeyfunc.c</B>[292]</A>==<BLOCKQUOTE><PRE>
#include &quot;defkeyfunc.h&quot;
#include &quot;err.h&quot;
#include &quot;buildtype.h&quot;
#include &quot;type.h&quot;

#include &lt;stdio.h&gt;

<A HREF="#m289"><I>Guarantee DefTableKey for function</I>[289]</A>
<A HREF="#m290"><I>Guarantee declaration for DefTableKey</I>[290]</A>
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<A NAME="s11.3"><H2>11.3  Specification files</H2></A>

<BLOCKQUOTE>
<A NAME="m293"><B>compute.lido</B>[293]</A>==<BLOCKQUOTE><PRE>
<A HREF="#m278"><I>Rule computations</I>[278]</A>
<A HREF="#m281"><I>Required types</I>[281]</A>
<A HREF="#m279"><I>Miscellaneous Types</I>[279]</A>
<A HREF="#m280"><I>Shut Up</I>[280]</A>
<A HREF="#m284"><I>Unary Indication rules</I>[284]</A>
<A HREF="#m285"><I>Binary Indication rules</I>[285]</A>
<A HREF="#m282"><I>Get return type of function_definition</I>[282]</A>
<A HREF="#m286"><I>Sanity Checks for constant values</I>[286]</A>
<A HREF="#m288"><I>Sanity checks for expression types</I>[288]</A>
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


The following line is required to make ELI find the Oil header file
with all of the Oil definitions in it.
<BLOCKQUOTE>
<A NAME="m294"><B>compute.specs</B>[294]</A>==<BLOCKQUOTE><PRE>
$/oil/oiladt2.h
$/Adt/csm.h
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


<BLOCKQUOTE>
<A NAME="m295"><B>compute.head</B>[295]</A>==<BLOCKQUOTE><PRE>
#include &quot;defkeyfunc.h&quot;
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>


Another attribute of a <TT>DefTableKey</TT> is an oil type, which is used when
the <TT>DefTableKey</TT> refers to a type.
<BLOCKQUOTE>
<A NAME="m296"><B>compute.pdl</B>[296]</A>==<BLOCKQUOTE><PRE>
&quot;oiladt2.h&quot;
OilOp         : tOilOp;
IsKnownConst: int;
</PRE></BLOCKQUOTE>
This macro is attached to a product file.
</BLOCKQUOTE>

</HTML>
